# **KS0193 keyestudio Self-balancing Car Kit**

![](media/ed976d4f7f20a281b531b76a84cbf80c.jpeg)

# 먼저 읽어보세요

**링크에서 APP, 코드 및 라이브러리를 다운로드하세요: <https://fs.keyestudio.com/KS0193>**

# 1.개요

직접 미니 밸런스 카를 DIY하는 방법은 무엇인가요? 이 밸런스 카 키트는 아두이노 개발 플랫폼을 기반으로 합니다. 우리는 주로 Keyestudio V4.0 (Black) 메인 컨트롤 보드를 코어로 사용하고, 내장된 MPU-6050이 있는 밸런스 실드를 드라이브 보드로 사용하여 카 바디 자세를 테스트합니다.

밸런스 실드는 블루투스 인터페이스가 함께 제공되며, 블루투스 XBee 모듈과 완전히 호환됩니다 (안드로이드 시스템만 호환).

블루투스에 연결하면 블루투스 APP으로 밸런스 카의 이동 방향을 쉽게 제어할 수 있어 다양한 독특한 자세를 만들 수 있습니다.

작동 제어를 용이하게 하기 위해 블루투스 APP에는 키와 중력 제어 모드가 모두 있습니다.

또한, 밸런스 각도와 PID 매개변수를 조정하는 기능을 추가하여 완벽하게 밸런스 카를 조정하고 제어할 수 있습니다.

어떻게 플레이할지 걱정하지 마세요. 우리는 모든 조립 구성품을 제공할 수 있으며, 해당 설치, 디버깅 방법 및 프로그램도 제공합니다.

# 2.작동 원리

자체 밸런싱 카는 카 바디의 힘을 사용하여 상대적인 밸런스를 유지하며, 이는 동적 밸런스의 과정입니다.

카의 밸런스를 유지하는 힘은 바퀴의 운동에서 비롯되며, 두 개의 DC 모터에 의해 구동됩니다.

카의 바디 제어는 다음과 같은 세 가지 제어 작업으로 나눌 수 있습니다:

**1. 밸런스 제어:** 카의 바퀴 전진 및 후진 회전을 제어하여 카를 똑바로 유지하고 밸런스를 맞춥니다.

**2. 속도 제어:** 카의 기울기를 제어하여 전후 이동 및 속도 제어를 실현합니다. 실제로 모터 속도를 제어하여 이루어집니다.

**3. 방향 제어:** 카의 두 모터 사이의 회전 속도 차이를 제어하여 방향 전환을 실현합니다.

이렇게 하면 세 가지 제어 작업을 이해하는 것이 상대적으로 간단합니다.

그러나 최종 제어 과정에서는 세 가지 작업이 서로 결합되어 서로 간섭합니다.

핵심은 카의 밸런스를 제어하는 것이며, 속도와 방향 제어는 가능한 한 부드럽게 해야 합니다.

# 3.밸런스 카 매개변수

**모터 매개변수:**

작동 전압: DC12V

감속비: 1:30

무부하 전류: ≤100mA

무부하 속도: 247rpm

정격 토크: 1.4 Kg.cm

정격 토크: 137.3mN.m

정격 속도: 160rpm

정격 전류: ≤0.45A

정지 토크: 5.5 Kg.cm

정지 전류: 2.4A

감속기 길이: 22mm

작동 전압: DC 9-12V

모터 드라이브 칩: TB6612FNG

바디 자세 감지: MPU-6050

전원 제어 스위치 포함

블루투스 통신 제어를 위한 블루투스 제어 스위치 포함

**특별히 주의하세요:**

밸런스 실드는 블루투스 통신을 제어하는 슬라이드 스위치가 함께 제공됩니다.

소스 코드를 업로드할 때 반드시 슬라이드 스위치를 OFF로 설정하세요; 그렇지 않으면 코드 업로드가 실패합니다.

블루투스 모듈에 연결할 때 슬라이드 스위치를 ON으로 설정해야 합니다.

![](media/ca17b05327464d5ccfe69be52cd49bb6.png)

# 4.키트 목록

키트 패키징에는 이 자체 밸런싱 카에 대한 모든 전자 구성품이 포함되어 있습니다. 각 프로젝트를 진행하면서 카를 제어하는 방법을 배우게 됩니다.

| 번호 | 구성품 | 수량 | 사진 |
| ---- | ------------------------------------------------------------ | -------- | :----------------------------------------------------------: |
| 1 | 이중 패스 M3*45MM 육각 구리 기둥 | 4 | ![img](./media/wps1.png) |
| 2 | 이중 패스 M3*10MM 육각 구리 기둥 | 4 | ![img](./media/wps22.png) |
| 3 | 검은색 M4*6 십자 나사 | 2 | ![img](./media/wps333.png) |
| 4 | M3*6MM 둥근 머리 나사 | 6 | ![img](./media/wps4.png) |
| 5 | M3*8MM 둥근 머리 나사 | 10 | ![img](./media/wps5.png) |
| 6 | M3*8MM 평평한 머리 십자 나사 | 4 | ![img](./media/wps6.png) |
| 7 | M3*12MM 평평한 머리 십자 나사 | 2 | ![img](./media/wps7.png) |
| 8 | M3*12MM 둥근 머리 나사 | 10 | ![img](./media/wps8.png) |
| 9 | M3 니켈 도금 너트 | 12 | ![img](./media/wps9.png) |
| 10 | 아크릴 판 팩 2pcs | 1 | ![img](./media/wps21.png) |
| 11 | 검은색+파란색 외경 68mm 두께 26mm 바퀴 | 2 | ![img](./media/wps23.png) |
| 12 | DC 기어 모터 홀 인코더 12V，1：30， | 2 | ![img](./media/wps24.png) |
| 13 | 6MM 구멍*18MM 길이 구리 육각 커플러 | 2 | ![img](./media/wps25.png) |
| 14 | 이중 헤드 6핀 PH2.030CM 커넥터 와이어 | 2 | ![img](./media/wps26.png) |
| 15 | 노란색-검은색 핸들 3*40MM 필립스 드라이버 | 1 | ![img](./media/wps28.png) |
| 16 | 타입 L M2 니켈 도금 내부 육각 렌치 | 1 | ![img](./media/wps29.png) |
| 17 | 18650 3셀 AA 배터리+플러그(18650 배터리 미포함) | 1 | ![img](./media/wps30.png) |
| 18 | Keyestudio 밸런스 실드 V3 (검은색 및 친환경) | 1 | ![img](./media/wps31.png) |
| 19 | Keyestudio v4.0 메인 컨트롤 보드 | 1 | ![img](./media/wps32.jpeg) |
| 20 | AM/BM 투명 파란색 OD:5.0 L=50cm USB 케이블 | 1 | ![img](./media/wps33.png) |
| 21 | Keyestudio 블루투스 XBee HC-06 | 1 | ![img](./media/wps34.png) |
| 22 | 모터 철 홀더 | 1 | ![img](./media/wps35.png) |
| 23 | 검은색 와인딩 튜브 | 1 | ![img](./media/wps36.jpg) |

# 5.조립 단계

**⑴** 아래에 표시된 모든 구성품을 준비하세요.

![](media/b5617b03012f591e915031216dafed40.jpeg)

![](media/93d98b25cca1a4818006f8a69d59e8ab.png)

**⑵** 먼저, 아래 아크릴 판을 설치합니다.

![](media/dec4c84f37e4ab50fecfea53373b6261.jpeg)

다음 부품을 찾아보세요:

- 아래 아크릴 판

- 이중 패스 M3\*10MM 육각 구리 기둥 x 4pcs

- M3\*8MM 나사 x 4pcs

- M3\*12MM 평평한 머리 나사 x 2pcs

- M3 니켈 도금 너트 x 2pcs

- 배터리 케이스

배터리 케이스와 구리 기둥을 아크릴 판에 장착합니다.

4pcs M3\*10MM 구리 기둥을 4pcs M3\*8MM 나사로 아크릴 판에 고정하세요.

![](media/ba542135eb736aa0edd7cab10139b8f1.jpeg)

그 다음, 2pcs M3\*12MM 평평한 머리 나사와 2pcs M3 니켈 도금 너트로 배터리 케이스를 아크릴 판에 장착하세요.

![](media/9d62646249ba348a458b8ba00cd351dd.jpeg)

![](media/dfcb07bace0b5ba332bb9373a59e5142.jpeg)

**⑶** 다음으로, 아래 아크릴 판에 모터와 바퀴를 설치합니다.

다음 부품을 찾아보세요:

- 배터리 케이스가 장착된 아래 아크릴 판
- M3\*12MM 둥근 머리 나사 x 8pcs
- M3 니켈 도금 너트 x 8pcs
- M4\*6MM 검은색 나사 x 2pcs
- 두 개의 바퀴
- 두 개의 검은색 커넥터
- 두 개의 모터
- 두 개의 구리 육각 커플러
- M2 렌치 타입 L

![](media/381d37ae3bab9c04276f426f6a254f33.jpeg)

8pcs M3\*12MM 둥근 머리 나사와 8pcs M3 니켈 도금 너트로 두 개의 검은색 커넥터를 아크릴 판에 장착하세요. 아래에 표시됩니다.

![](media/5d79b03196991a5bb8f702e95b0cb9ad.jpeg)

각 모터에는 가방에 6개의 나사가 있습니다. 나사를 사용하여 두 개의 모터를 검은색 커넥터에 장착하세요.

![](media/fe987b19b5de94b5f264fa6d9a37b410.jpeg)

![](media/870d6c7b8bfa58b251a0c24c1b051e4e.jpeg)

각 구리 육각 커플러를 두 개의 나사로 조이세요. 그런 다음 렌치를 사용하여 두 개의 육각 커플러를 두 개의 모터에 고정하세요.

![](media/028702031b4e21b3871a4e2e4798927b.jpeg)

![](media/d213e3c8379078e2693e879c2793cdf1.jpeg)

마지막으로, 2pcs M4\*6MM 검은색 나사를 사용하여 두 개의 바퀴를 두 개의 구리 육각 커플러에 고정하세요.

![](media/3b6b8a394e30efc92cd1a0a9da7a3169.jpeg)

![](media/173a5e9757a5df4e9f146bf5fa31dbc8.jpeg)

![](media/ed6fbb3987cb766a9ffa0b70293ae7fc.jpeg)

지금까지 아래 모터 바퀴가 잘 설치되었습니다!

**⑷** 마지막 단계는 컨트롤 보드와 위 아크릴 판을 설치하는 것입니다.

![](media/b43ff4417ad0890b1ad8f8f198de7f24.jpeg)

- 위 아크릴 판

- V4.0 컨트롤 보드

- keyestudio 밸런스 실드

- 블루투스 XBee 모듈 HC-06

- M3\*6MM 둥근 머리 나사 x 3pcs

- M3\*45MM 구리 기둥 x 4pcs

- M3\*8MM 둥근 머리 나사 x 8pcs

- 6핀 30CM 커넥터 와이어 x 2pcs

3pcs M3\*6MM 둥근 머리 나사로 V4.0 컨트롤 보드를 아크릴 판에 장착된 4pcs M3\*10MM 구리 기둥에 고정하세요.

![](media/3b2b69724aeaaf40334572d46cb089a3.jpeg)

그 다음, keyestudio 밸런스 실드를 V4.0 컨트롤 보드에 쌓고, 블루투스 XBee 모듈 HC-06을 밸런스 실드에 꽂으세요.

![](media/1aa06f4d7152f9f9bfd865f79b7aad59.jpeg)

6핀 PH2.0 30CM 커넥터 와이어를 사용하여 모터를 밸런스 실드에 연결하세요. 모터를 가장 가까운 모터 커넥터에 연결하세요.

![](media/72513a28bc92107c9bae3e65a29db59b.jpeg)

![](media/b8368175fb4f0abb514ae7b1f5fe1911.jpeg)

그 후, 4pcs M3\*45MM 구리 기둥을 아크릴 판에 4pcs M3\*8MM 둥근 머리 나사로 고정하고, V4.0의 DC 블랙 잭에 배터리 플러그를 잘 연결하세요.

![](media/542910ede8494a06a126a09104425817.jpeg)

뒷면은 아래에 표시됩니다:

![](media/7bbab9da7f512230d481fda44886c5ce.jpeg)

마지막 부분은 4pcs M3\*45MM 구리 기둥에 4pcs M3\*8MM 둥근 머리 나사로 위 아크릴 판을 설치하는 것입니다.

![](media/3465955d0c9cf3934abf5c22f6146ae4.jpeg)

축하합니다! 밸런스 카가 잘 설치되었습니다.

![](media/ed976d4f7f20a281b531b76a84cbf80A.jpg)

# 6.프로젝트

## 프로젝트 1: 아두이노 시작하기

**V4.0 컨트롤 보드**

플랫폼으로 시작할 때 V4.0은 전자 및 코딩을 시작하는 데 가장 좋은 보드입니다. 이 플랫폼을 처음 접하는 경우 V4.0은 가지고 놀 수 있는 가장 견고한 보드입니다.

![](media/88e350302076928641bee474abbfd7f3.jpeg)

V4.0 보드를 살펴보겠습니다.

![](media/709d9ef695f98e63ee0501030b455a69.jpeg)

**밸런스 카 실드**

밸런스 실드는 이 밸런스 카의 중요한 부분입니다. 이를 통해 밸런스 카를 더 간단하게 DIY할 수 있습니다.

V4.0 보드와 완전히 호환됩니다; 컨트롤 보드에 쌓기만 하면 됩니다.

밸런스 실드는 6612FNG 칩으로 두 개의 DC 모터를 구동하고, 두 개의 흰색 커넥터로 DC 모터를 연결하며, 밸런스 실드와 V4.0에 전원을 공급하는 DC 전원 잭을 포함합니다;

또한 큰 슬라이드 스위치로 전원 스위치를 제어하고, MPU-6050로 자세를 테스트하며, XBEE 블루투스 인터페이스로 블루투스 모듈과 통신하며, 블루투스 모듈의 통신을 제어하는 작은 슬라이드 스위치를 포함합니다.

또한 버튼과 액티브 버저가 있습니다.

실드의 컨트롤 핀은 모두 여성 헤더로 실드에 가져오고, 시리얼 포트와 I2C 통신 핀은 핀 헤더로 가져옵니다.

**참고:** 모터를 실드의 모터 커넥터에 연결하세요.

![image-20230510085238394](media/image-20230510085238394.png)

**핀아웃:**

![](media/e9497ec95579d3b4a2e863fc8ac7a24f.jpeg)

**아두이노 IDE 설치**

![](/media/ide.png)

**소프트웨어를 다운로드하고, 드라이버를 설치하고, 코드를 업로드하고, 라이브러리 파일을 설치하는 방법을 배우기 위해 링크를 클릭하세요.**

**[https://getting-started-with-arduino.readthedocs.io](https://getting-started-with-arduino.readthedocs.io/en/latest/Arduino%20IDE%20Tutorial.html)**

## 프로젝트 2: 버튼과 버저

**설명:**

이전 프로젝트에서 아두이노 소프트웨어 환경을 사용하는 방법을 배웠습니다.

시도해 보겠습니까? 좋습니다. 이 프로젝트는 아두이노 프로그래밍 세계에 들어가는 기본 프로그램을 제공합니다.

![](media/4503905b43c71037a46a28ccd8efe8ee.jpeg)

keyestudio 밸런스 카 실드에는 KEY_13 버튼과 액티브 버저가 있습니다. 구체적으로 버튼은 V4.0의 핀 D13으로 제어되고, 액티브 버저는 V4.0의 핀 D11으로 제어됩니다.

![](media/ca17b05327464d5ccfe69be52cd49bb6.png)

실험에서 버튼으로 버저를 제어합니다. 버튼을 누르면 버저가 울립니다.

![](media/f680ff553db7faf1f0b681fb2c8f6996.png)

액티브 버저에는 진동 회로가 있습니다. 사실, 핀 D11을 HIGH로 설정하면 버저가 울립니다. 우리는 패시브 버저의 설정 방법을 시뮬레이션합니다. 액티브 버저가 다른 소리를 출력하도록 다른 스퀘어 웨이브를 설정합니다.

**소스 코드:**

```c
const int buz = 11;    // 버저 핀 설정
const int btn = 13;    // 버튼 핀 설정
int button;    // 버튼 변수

void setup() 
{
  pinMode(btn,INPUT);       // INPUT 상태로 설정
  pinMode(buz,OUTPUT);       // OUTPUT 상태로 설정
}

void loop() 
{
  button = digitalRead(btn);       // 버튼 값을 변수 button에 할당
  if(button == 0)    // 버튼을 누르면
  {
    delay(10);    // 지연 시간
    if(button == 0)     // 다시 판단, 버튼이 눌렸으면
    {
      buzzer();  // 버저 서브함수 실행
    }
  }
  else        // 버튼이 눌리지 않음
  {
    digitalWrite(buz,LOW);    // 버저가 울리지 않음
  }
}

//버저가 틱 소리를 냄
void buzzer()      
{
    for(int i=0;i<50;i++)
    {
    digitalWrite(buz,HIGH);
    delay(1);
    digitalWrite(buz,LOW);
    delay(1);
    }
    delay(50);
    for(int i=0;i<50;i++)
    {
    digitalWrite(buz,HIGH);
    delay(1);
    digitalWrite(buz,LOW);
    delay(1);
    }
}
```

**테스트 결과**

밸런스 카를 잘 설치하고, 소스 코드를 업로드하고 전원을 켜세요; 슬라이드 스위치를 ON으로 설정하고 실드의 KEY_13 버튼을 누르세요.

밸런스 실드의 액티브 버저가 울립니다; 그렇지 않으면 울리지 않습니다.

## 프로젝트 3: TB6612 모터 구동

**설명:**

프로젝트에서 우리는 오른쪽 모터의 방향을 V4.0의 핀 D8 D12로 제어하고, 속도는 핀 D10으로 제어합니다. 왼쪽 모터의 방향은 V4.0의 핀 D7 D6으로 제어하고, 속도는 핀 D9로 제어합니다.

![](media/a6ae40878065311168a15a0ed46c607e.jpeg)

**지정된 제어 방법은 아래 표를 참조하세요:**

| D8   | D12  | D10/PWM | 오른쪽 모터 | D7   | D6   | D9/PWM | 왼쪽 모터 |
|------|------|---------|-------------|------|------|--------|------------|
| HIGH | LOW  | 0-255   | 전진        | HIGH | LOW  | 0-255  | 전진       |
| LOW  | HIGH | 0-255   | 후진        | LOW  | HIGH | 0-255  | 후진       |
| HIGH | HIGH | /       | 정지        | HIGH | HIGH | /      | 정지       |
| LOW  | LOW  | /       | 정지        | LOW  | LOW  | /      | 정지       |

D9 D10은 PWM 핀으로, 디지털 출력 또는 아날로그 출력으로 사용할 수 있습니다.

아날로그 출력으로 사용할 때 ARDUINO의 analogWrite() 함수를 호출해야 하며, 이 analogWrite() 함수는 0-255 범위로 제어됩니다.

analogWrite(255)를 호출하면 100% 듀티 사이클(항상 켜짐)을 요청하고, analogWrite(127)는 50% 듀티 사이클(반 시간 켜짐)입니다.

코드에서 D9와 D10에 설정된 PWM 값이 클수록 두 모터의 속도가 빨라집니다.

아래에서 우리는 두 모터를 전진과 후진으로만 간단히 설정합니다.

**소스 코드:**

```c
//TB6612 핀
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

void setup() 
{
  Serial.begin(9600);          // 보드레이트를 9600으로 설정
  
  pinMode(right_R1,OUTPUT);     // 모든 TB6612핀을 OUTPUT으로 설정
  pinMode(right_R2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_L,OUTPUT);
}

void loop() 
{
  // 두 모터 전진
  digitalWrite(right_R1,HIGH);
  digitalWrite(right_R2,LOW);
  digitalWrite(left_L1,HIGH);
  digitalWrite(left_L2,LOW);
  analogWrite(PWM_R,100);   // PWM 값 0~255 쓰기（속도）
  analogWrite(PWM_L,100);
}
```

**테스트 결과**

밸런스 카를 잘 설치하고, 소스 코드를 업로드하고 전원을 켜세요; 슬라이드 스위치를 ON으로 설정하세요.

두 왼쪽과 오른쪽 모터가 전진합니다.

![](media/a6ae40878065311168a15a0ed46c607e.jpeg)

## 프로젝트 4: 홀 인코더 테스트

**설명:**

이전에서 D9 D10의 PWM 값으로 모터 속도를 설정하는 방법을 소개했습니다.

그러나 지정된 속도를 얻는 방법은 무엇인가요? 홀 인코더를 사용하여 테스트할 수 있습니다.

![](media/2c63ece82b926aa57e36a5d4f8a5b5e5.png)

![image-20230510090657965](media/image-20230510090657965.png)

이 프로젝트에서 100ms 내에 홀 인코더에서 얻은 펄스 수로 지정된 속도를 계산하는 방법을 배웁니다.

**소스 코드:**

```c
//TB6612 핀
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

const int PinA_left = 5;    // 왼쪽 모터의 펄스 핀을 D5로 설정
const int PinA_right = 4;    // 오른쪽 모터의 펄스 핀을 D4로 설정

int times=0,newtime=0,d_time=100;   // 시간, 새 시간, 시간 간격
int valA=0,valB=0,flagA=0,flagB=0;    // 펄스 수를 계산하는 변수 valA와 valB

void setup() 
{
  Serial.begin(9600);
  
  pinMode(right_R1,OUTPUT);    // TB6612 핀을 OUTPUT으로 설정
  pinMode(right_R2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_L,OUTPUT);

  pinMode(PinA_left,INPUT);    // 펄스 핀을 INPUT으로 설정
  pinMode(PinA_right,INPUT);

}

void loop() 
{
  //두 모터 전진
  digitalWrite(right_R1,HIGH);
  digitalWrite(right_R2,LOW);
  digitalWrite(left_L1,HIGH);
  digitalWrite(left_L2,LOW);
  analogWrite(PWM_R,100);   // PWM 값 0~255 쓰기（속도）
  analogWrite(PWM_L,200);

  newtime=times=millis();     // newtime과 times를 프로그램이 여기까지 실행한 시간으로 같게 만듦
  while((newtime-times)<d_time)    // 설정 d_time보다 작으면 항상 루프
  {
    if(digitalRead(PinA_left)==HIGH&&flagA==0)   // HIGH 감지 시
    {
      valA++;      // valA 1 증가
      flagA=1;
    }
    if(digitalRead(PinA_left)==LOW&&flagA==1)    // LOW 시
    {
      valA++;     // valA 1 증가
      flagA=0;
    }
    
    if(digitalRead(PinA_right)==HIGH&&flagB==0)
    {
      valB++;
      flagB=1;
    }
    if(digitalRead(PinA_right)==LOW&&flagB==1)
    {
      valB++;
      flagB=0;
    }
    newtime=millis();        // newtime은 프로그램이 여기까지 실행한 시간
  }
  Serial.println(valA);      // 시리얼 모니터에 valA와 B 값 출력
  Serial.println(valB);
  valA=valB=0;             // 0으로 설정
}
```

**테스트 결과**

밸런스 카를 잘 설치하고, 소스 코드를 업로드하고 전원을 켜세요; 슬라이드 스위치를 ON으로 설정하세요.

아두이노 IDE를 열고 보드레이트를 9600으로 설정하세요. 시리얼 모니터가 100ms 내에 홀 인코더에서 얻은 펄스 수를 팝업합니다 (왼쪽과 오른쪽 모터에 해당).

아래 그림을 참조하세요.

![](media/d41314adde529353adc5efe78c535192.png)

## 프로젝트 5: 내부 타이머 인터럽트

**설명:**

이전에서 홀 인코더의 펄스 수를 100ms 내에 얻는 방법을 배웠습니다.

이제 V4.0 보드의 내장 내부 타이머(timer2)를 사용합니다. 홀 인코더에서 얻은 펄스 수로 100ms 내에 지정된 속도를 계산합니다.

**소스 코드:**

테스트하기 전에 해당 라이브러리를 추가하세요.

아래 링크의 방법을 참조하세요:

<https://wiki.keyestudio.com/How_to_Install_Arduino_Library>

```c
#include <MsTimer2.h>

//TB6612 핀
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

const int PinA_left = 5;        // 왼쪽 모터의 펄스 핀을 D5로 설정
const int PinA_right = 4;       // 오른쪽 모터의 펄스 핀을 D4로 설정

int times=0,newtime=0,d_time=100;   // 시간, 새 시간, 시간 간격
int valA=0,valB=0,flagA=0,flagB=0;   // 펄스 수를 계산하는 변수 valA와 valB

void setup() 
{
  Serial.begin(9600);
  
  pinMode(right_R1,OUTPUT);     // TB6612 핀을 OUTPUT으로 설정
  pinMode(right_R2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_L,OUTPUT);

  pinMode(PinA_left,INPUT);      // 펄스 핀을 INPUT으로 설정
  pinMode(PinA_right,INPUT);
  
  MsTimer2::set(100, inter); // 100ms마다 인터럽트 트리거
  MsTimer2::start();    // 인터럽트 시작
}

void loop() 
{
  //두 모터 전진
  digitalWrite(right_R1,HIGH);
  digitalWrite(right_R2,LOW);
  digitalWrite(left_L1,HIGH);
  digitalWrite(left_L2,LOW);
  analogWrite(PWM_R,100);    // PWM 값 0~255 쓰기（속도）
  analogWrite(PWM_L,200);

  if(digitalRead(PinA_left)==HIGH&&flagA==0)     // 펄스 값 계산
    {
      valA++;
      flagA=1;
    }
    if(digitalRead(PinA_left)==LOW&&flagA==1)
    {
      valA++;
      flagA=0;
    }
    
    if(digitalRead(PinA_right)==HIGH&&flagB==0)
    {
      valB++;
      flagB=1;
    }
    if(digitalRead(PinA_right)==LOW&&flagB==1)
    {
      valB++;
      flagB=0;
    }
    
}

//인터럽트 함수
void inter()    
{
    sei();    // 전체 인터럽트 허용
    Serial.print("valA = ");     // 시리얼 모니터에 펄스 값 출력
    Serial.println(valA);
    Serial.print("valB = ");
    Serial.println(valB);
    valA = valB = 0;
}
```

**테스트 결과**

밸런스 카를 설치하고 전원을 켜고 소스 코드를 업로드하세요;

슬라이드 스위치를 ON으로 설정하세요.

아두이노 IDE의 모니터를 열고 보드레이트를 9600으로 설정하세요.

시리얼 모니터가 100ms 내에 홀 인코더에서 얻은 펄스 수를 팝업합니다 (왼쪽과 오른쪽 모터에 해당).

아래 그림을 참조하세요.

![](media/41e4099873055457571d638252b9c665.png)

## 프로젝트 6: 블루투스 테스트

**설명:**

![](media/949c3308572221676761f2f9afe9bf68.png)

키트에는 블루투스 XBee 모듈이 포함되어 있으며, 안드로이드 시스템과 호환됩니다.

Keyestudio Bluetooth XBee 무선 모듈 HC-06에는 컴팩트한 크기, XBEE 실드와 호환, 다양한 3.3V MCU 시스템에 적합한 기능이 있습니다. 또한 효율적인 온보드 안테나가 있습니다.

더 많은 내용은 여기 링크를 확인하세요.

<https://wiki.keyestudio.com/Ks0144_keyestudio_XBee_Bluetooth_Wireless_Module_HC-06>

이 프로젝트에서 안드로이드 블루투스와 밸런스 카가 통신하도록 블루투스 APP를 사용하는 방법을 배웁니다. 블루투스 APP를 사용하여 밸런스 카 이동을 무작위로 제어할 수 있습니다.

![](media/e43a43d30d7fa6c0b880a55872573b4b.jpeg)

**참고:**

keyestudio 밸런스 실드에는 블루투스 통신을 제어하는 슬라이드 스위치가 있습니다.

소스 코드를 업로드할 때 반드시 스위치를 OFF로 설정하세요; 그렇지 않으면 코드 업로드가 실패합니다.

블루투스 모듈에 연결할 때 스위치를 ON으로 설정해야 합니다.

**블루투스 APP를 사용하는 방법?**

- 밸런스 카를 설치하고, 소스 코드를 업로드하고 전원을 켜세요; 전원 스위치를 ON으로 설정하세요; 블루투스 스위치를 ON으로 설정하세요.
    
- 블루투스 APP를 설치하세요. 그러면 휴대폰에 아래 아이콘이 표시됩니다.

![image-20230510091355397](media/image-20230510091355397.png)

APP를 다운로드하려면 아래 링크를 클릭하세요:

<https://drive.google.com/open?id=1L69xdfmOvfhg0Wjh_p2FrtRkhs1h0fEu>

- APP를 열어 아래 인터페이스를 보세요.

![](media/c9025f5cc50b1c07224b747d3b8a75c8.png)

![](media/1f4c2a18315a5113785e94e790e7c6e8.png)

- 블루투스 아이콘을 탭하세요![image-20230426163821621](media/image-20230426163821621.png); 블루투스 검색 및 페어링 인터페이스로 들어가세요.

![image-20230510091436455](media/image-20230510091436455.png)

- HC-06을 탭하세요 (처음 검색 시 주소이므로 주소를 탭하세요); PIN은 1234입니다.

![image-20230510091459462](media/image-20230510091459462.png)

- 마지막으로 페어된 장치를 보게 됩니다.

![image-20230510091516036](media/image-20230510091516036.png)

- 휴대폰에서 HC-06에 연결하세요; 이제 APP의 블루투스 연결 아이콘을 탭하세요 ![image-20230426163848425](media/image-20230426163848425.png).

![](media/b3fdf12f728b45fd74de8911e22a0a36.png)

- 그런 다음 APP에 표시된 ![image-20230426163912972](media/image-20230426163912972.png)를 탭하세요. 이제 블루투스가 성공적으로 연결되었습니다.
- 블루투스가 연결되면 APP의 키 ![image-20230426163936649](media/image-20230426163936649.png)를 탭하세요. 두 모터가 전진합니다;
- 키 ![image-20230426163944987](media/image-20230426163944987.png)를 탭하세요. 두 모터가 정지합니다;
- 키 ![image-20230426163957010](media/image-20230426163957010.png)를 탭하세요. 두 모터가 후진합니다.

**소스 코드:**

```c
//TB6612 핀
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;
char val;   // 블루투스 변수

void setup() 
{
  Serial.begin(9600);
  
  pinMode(right_R1,OUTPUT);   // TB6612 핀을 OUTPUT으로 설정
  pinMode(right_R2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_L,OUTPUT);
}

void loop() 
{
  if(Serial.available())    // 시리얼 버퍼 값이 사용 가능하면
  {
    val = Serial.read();      // 시리얼 포트에서 읽은 값을 val에 할당
    Serial.println(val);
    switch(val)             // 스위치 문
    {
      case 'F': front(); break;     // 모터 전진
      case 'B': back(); break;       // 후진
      case 'S': Stop();break;    // 정지
    }
  }
}

//전진
void front()
{
  digitalWrite(right_R1,HIGH);
  digitalWrite(right_R2,LOW);
  digitalWrite(left_L1,HIGH);
  digitalWrite(left_L2,LOW);
  analogWrite(PWM_R,100);
  analogWrite(PWM_L,100);
}
//후진
void back()
{
  digitalWrite(right_R1,LOW);
  digitalWrite(right_R2,HIGH);
  digitalWrite(left_L1,LOW);
  digitalWrite(left_L2,HIGH);
  analogWrite(PWM_R,100);
  analogWrite(PWM_L,100);
}
//정지
void Stop()
{
  digitalWrite(right_R1,LOW);
  digitalWrite(right_R2,HIGH);
  digitalWrite(left_L1,LOW);
  digitalWrite(left_L2,HIGH);
  analogWrite(PWM_R,0);
  analogWrite(PWM_L,0);
}
```

## 프로젝트 7: MPU6050 테스트

**설명:**

밸런스 카를 DIY할 때 먼저 자세를 얻어야 합니다. 가장 많이 사용되는 것은 가속도계와 자이로스코프를 통해입니다.

이론적으로 두 축 가속도계만 필요합니다 (직선 방향의 Z축과 카 이동 방향의 Y축). 그리고 카 바퀴의 X축 방향 각속도를 계산하는 단일 축 자이로스코프.

![image-20230510091703291](media/image-20230510091703291.png)

이 프로젝트에서 keyestudio 밸런스 실드의 내장 MPU-6050 칩을 사용하여 3축 가속도계와 3축 자이로스코프의 데이터를 테스트하고, 시리얼 모니터에 인쇄합니다.

가속도 범위는 +-2g; 자이로스코프 범위는 +-250°/S입니다.

**소스 코드:**

```c
#include <Wire.h>
 
long accelX, accelY, accelZ;      // 전체 변수로 설정; 함수 내부에서 직접 사용할 수 있음.
float gForceX, gForceY, gForceZ;
 
long gyroX, gyroY, gyroZ;
float rotX, rotY, rotZ;
 
void setup() {
  Serial.begin(9600);
  Wire.begin();
  setupMPU();
}
 
void loop() {
  recordAccelRegisters();
  recordGyroRegisters();
  printData();
  delay(100);
}
 
void setupMPU(){
  // REGISTER 0x6B/REGISTER 107:Power Management 1
  Wire.beginTransmission(0b1101000); //This is the I2C address of the MPU (b1101000/b1101001 for AC0 low/high datasheet Sec. 9.2)
  Wire.write(0x6B); //Accessing the register 6B/107 - Power Management (Sec. 4.30) 
  Wire.write(0b00000000); //Setting SLEEP register to 0, using the internal 8 Mhz oscillator
  Wire.endTransmission();
 
  // REGISTER 0x1b/REGISTER 27:Gyroscope Configuration
  Wire.beginTransmission(0b1101000); //I2C address of the MPU
  Wire.write(0x1B); //Accessing the register 1B - Gyroscope Configuration (Sec. 4.4) 
  Wire.write(0x00000000); //Setting the gyro to full scale +/- 250deg./s (转化为rpm:250/360 * 60 = 41.67rpm) ;The highest can be converted to 2000deg./s 
  Wire.endTransmission();
  
  // REGISTER 0x1C/REGISTER 28:ACCELEROMETER CONFIGURATION
  Wire.beginTransmission(0b1101000); //I2C address of the MPU
  Wire.write(0x1C); //Accessing the register 1C - Acccelerometer Configuration (Sec. 4.5) 
  Wire.write(0b00000000); //Setting the accel to +/- 2g（if choose +/- 16g，the value would be 0b00011000）
  Wire.endTransmission(); 
}
 
void recordAccelRegisters() {
  // REGISTER 0x3B~0x40/REGISTER 59~64
  Wire.beginTransmission(0b1101000); //I2C address of the MPU
  Wire.write(0x3B); //Starting register for Accel Readings
  Wire.endTransmission();
  Wire.requestFrom(0b1101000,6); //Request Accel Registers (3B - 40)
 
  // 왼쪽 시프트 <<와 비트 연산 | 사용  Wire.read() 한 번 읽기 1바이트，다음 호출 시 다음 주소의 데이터를 자동으로 읽음.
  while(Wire.available() < 6);  // 슬레이브 머신에서 6바이트 데이터가 모두 전송될 때까지 기다림（읽기 전에 버퍼에 모든 데이터가 저장되었는지 확인해야 함）
  accelX = Wire.read()<<8|Wire.read(); //첫 두 바이트를 accelX에 저장（정의된 긴 값으로 자동 저장）
  accelY = Wire.read()<<8|Wire.read(); //중간 두 바이트를 accelY에 저장
  accelZ = Wire.read()<<8|Wire.read(); //마지막 두 바이트를 accelZ에 저장
  processAccelData();
}
 
void processAccelData(){
  gForceX = accelX / 16384.0;     //float = long / float
  gForceY = accelY / 16384.0; 
  gForceZ = accelZ / 16384.0;
}
 
void recordGyroRegisters() 
{
  // REGISTER 0x43~0x48/REGISTER 67~72
  Wire.beginTransmission(0b1101000); //I2C address of the MPU
  Wire.write(0x43); //Starting register for Gyro Readings
  Wire.endTransmission();
  Wire.requestFrom(0b1101000,6); //Request Gyro Registers (43 ~ 48)
  while(Wire.available() < 6);
  gyroX = Wire.read()<<8|Wire.read(); //첫 두 바이트를 accelX에 저장
  gyroY = Wire.read()<<8|Wire.read(); //중간 두 바이트를 accelY에 저장
  gyroZ = Wire.read()<<8|Wire.read(); //마지막 두 바이트를 accelZ에 저장
  processGyroData();
}
 
void processGyroData() {
  rotX = gyroX / 131.0;
  rotY = gyroY / 131.0; 
  rotZ = gyroZ / 131.0;
}
 
void printData() {
  Serial.print("Gyro (deg)");
  Serial.print(" X=");
  Serial.print(rotX);
  Serial.print(" Y=");
  Serial.print(rotY);
  Serial.print(" Z=");
  Serial.print(rotZ);
  Serial.print(" Accel (g)");
  Serial.print(" X=");
  Serial.print(gForceX);
  Serial.print(" Y=");
  Serial.print(gForceY);
  Serial.print(" Z=");
  Serial.println(gForceZ);
}
```

**테스트 결과**

밸런스 카를 잘 설치하고, 소스 코드를 업로드하고 전원을 켜세요; 슬라이드 스위치를 ON으로 설정하세요.

아두이노 IDE를 열고 보드레이트를 9600으로 설정하세요. 시리얼 모니터가 값을 팝업합니다.

![](media/d868cb52acefe42eec83c99967b0f7f3.png)

## 프로젝트 8: 기울기 각도 및 각속도 값 계산

**설명:**

이전 프로젝트에서 MPU-6050 칩으로 카의 자세를 얻는 방법을 배웠습니다.

이 레슨에서 MPU-6050 칩으로 측정된 데이터를 사용하여 밸런스 카의 자세를 직접 얻습니다.

밸런스 카에 의해 감지된 기울기 각도와 각속도 값을 계산하는 방법을 배우고, 시리얼 모니터에 테스트 결과를 표시합니다.

**소스 코드:**

**참고:**

테스트하기 전에 해당 라이브러리를 추가하세요.

아래 링크의 방법을 참조하세요:

<https://wiki.keyestudio.com/How_to_Install_Arduino_Library>

```c
#include <MPU6050.h>      //MPU6050 라이브러리
#include <Wire.h>        //IIC 통신 라이브러리

MPU6050 mpu6050;     //MPU6050 객체 인스턴스화; 이름 mpu6050
int16_t ax, ay, az, gx, gy, gz;     //3축 가속도, 3축 자이로스코프 변수 정의

float Angle;   //각도 변수
int16_t Gyro_x;   //각속도 변수

void setup() 
{
  // I2C 버스 가입
  Wire.begin();                            //I2C 버스 시퀀스 가입
  Serial.begin(9600);                       //시리얼 모니터 열기, 보드레이트 9600 설정
  delay(1500);
  mpu6050.initialize();                       //MPU6050 초기화
  delay(2);
}

void loop() 
{
  mpu6050.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);     //IIC로 MPU6050 6축 데이터 ax ay az gx gy gz 얻기
  Angle = -atan2(ay , az) * (180/ PI);           //방사형 회전 각도 계산 공식; 음수 부호는 방향 처리
  Gyro_x = -gx / 131;              //자이로스코프로 계산된 X축 각속도; 음수 부호는 방향 처리
  Serial.print("Angle = ");
  Serial.print(Angle);
  Serial.print("   Gyro_x = ");
  Serial.println(Gyro_x);
}
```

**테스트 결과**

밸런스 카를 잘 설치하고, 소스 코드를 업로드하고 전원을 켜세요; 슬라이드 스위치를 ON으로 설정하세요.

아두이노 IDE를 열고 보드레이트를 9600으로 설정하세요. 시리얼 모니터가 값을 팝업합니다.

![](media/6c828cc1a4d67fcc4ab5d7ea62c76cf3.png)

**칼만 필터를 사용하여 각도를 계산하는 방법?**

**칼만 필터란 무엇인가?**

칼만 필터링은 입력과 출력의 선형 시스템 상태 방정식을 사용하여 시스템의 상태를 추정하는 알고리즘입니다.

관측 데이터에는 시스템의 노이즈와 간섭 효과가 포함되므로 최적 추정도 필터링 과정으로 볼 수 있습니다.

![](media/0bb60c33d5b04090245004b5623b884e.jpeg)

가속도계 데이터가 항상 100% 신뢰할 수 없는 이유?

가속도계는 중력력에 의해 발생하는 관성력을 측정합니다 (이상적으로 중력만). 그러나 장치의 가속 (운동)에 의해서도 발생할 수 있습니다.

따라서 가속도계가 상대적으로 안정된 상태라도 진동과 기계적 노이즈에 매우 민감합니다.

즉, 3축 가속도 값만 사용하여 얻은 개별 기울기 각도는 오류가 있으며, 오류가 큽니다. 칼만 필터링을 사용하여 가속도로 계산된 기울기 각도와 자이로스코프의 측정 각속도 값을 필터링해야 합니다.

**하지만 어떻게 이 작업을 수행할 수 있나요? 자이로스코프에 노이즈가 없나요?**

자이로스코프는 회전을 측정하므로 가속도계가 겪는 선형 기계적 운동 (노이즈 유형)에 덜 민감합니다.

그러나 자이로스코프에는 다른 유형의 문제, 예를 들어 회전이 중지될 때 제로 속도 값으로 돌아가지 않는 드리프트가 있습니다.

그럼에도 불구하고 가속도계와 자이로스코프의 데이터를 평균화하여 가속도계 데이터만 사용하여 현재 장치의 기울기 각도를 얻는 것보다 더 나은 추정을 얻을 수 있습니다.

따라서 가속도로 계산된 기울기 각도와 자이로스코프의 측정 각속도 값에 칼만 필터링을 수행하여 더 작고 안정적인 각도를 얻어야 합니다.

이 프로젝트에서 칼만 필터를 사용하여 밸런스 카의 밸런스 각도와 각속도를 계산하고, 시리얼 모니터에 테스트 데이터를 표시합니다.

**소스 코드:**

**참고:**

테스트하기 전에 해당 라이브러리를 추가하세요.

아래 링크의 방법을 참조하세요:

<https://wiki.keyestudio.com/How_to_Install_Arduino_Library>

```c
#include <MPU6050.h>      //MPU6050 라이브러리
#include <Wire.h>        //IIC 통신 라이브러리

MPU6050 mpu6050;     //MPU6050 객체 인스턴스화; 이름 mpu60500
int16_t ax, ay, az, gx, gy, gz;     //3축 가속도, 3축 자이로스코프 변수 정의
float Angle;
float Gyro_x,Gyro_y,Gyro_z;  //자이로스코프로 각 축의 각속도 계산

///////////////////////Kalman_Filter////////////////////////////
float Q_angle = 0.001;  //자이로스코프 노이즈 공분산
float Q_gyro = 0.003;    //자이로스코프 드리프트 노이즈 공분산
float R_angle = 0.5;    //가속도계 공분산
char C_0 = 1;
float dt = 0.005; //dt 값은 필터 샘플링 시간입니다.
float K1 = 0.05; //최적 추정의 편차를 계산하는 칼만 게인을 포함하는 함수입니다.
float K_0,K_1,t_0,t_1;
float angle_err;
float q_bias;    //자이로스코프 드리프트

float accelz = 0;
float angle;
float angleY_one;
float angle_speed;

float Pdot[4] = { 0, 0, 0, 0};
float P[2][2] = {{ 1, 0 }, { 0, 1 }};
float  PCt_0, PCt_1, E;

//////////////////////Kalman_Filter/////////////////////////
void setup() 
{
  // I2C 버스 가입
  Wire.begin();                            //I2C 버스 시퀀스 가입
  Serial.begin(9600);                       //시리얼 모니터 열기, 보드레이트 9600 설정
  delay(1500);
  mpu6050.initialize();                       //MPU6050 초기화
  delay(2);
}

void loop() 
{
  Serial.print("Angle = ");
  Serial.print(Angle);
  Serial.print("  K_angle = ");
  Serial.println(angle);
  Serial.print("Gyro_x = ");
  Serial.print(Gyro_x);
  Serial.print("  K_Gyro_x = ");
  Serial.println(angle_speed);

  mpu6050.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);     //IIC로 MPU6050 6축 ax ay az gx gy gz 얻기
  angle_calculate(ax, ay, az, gx, gy, gz, dt, Q_angle, Q_gyro, R_angle, C_0, K1);      //각도와 칼만 필터 얻기
}

/////////////////////////////angle calculate///////////////////////
void angle_calculate(int16_t ax,int16_t ay,int16_t az,int16_t gx,int16_t gy,int16_t gz,float dt,float Q_angle,float Q_gyro,float R_angle,float C_0,float K1)
{
  Angle = -atan2(ay , az) * (180/ PI);           //방사형 회전 각도 계산 공식; 음수 부호는 방향 처리
  Gyro_x = -gx / 131;              //자이로스코프로 계산된 X축 각속도; 음수 부호는 방향 처리
  Kalman_Filter(Angle, Gyro_x);            //칼만 필터
}

///////////////////////////////KalmanFilter/////////////////////
void Kalman_Filter(double angle_m, double gyro_m)
{
  angle += (gyro_m - q_bias) * dt;          //사전 추정
  angle_err = angle_m - angle;
  
  Pdot[0] = Q_angle - P[0][1] - P[1][0];    //방위각 오차 공분산 미분
  Pdot[1] = - P[1][1];
  Pdot[2] = - P[1][1];
  Pdot[3] = Q_gyro;
  
  P[0][0] += Pdot[0] * dt;    //사전 추정 오차 공분산 미분 적분
  P[0][1] += Pdot[1] * dt;
  P[1][0] += Pdot[2] * dt;
  P[1][1] += Pdot[3] * dt;
  
  //행렬 곱셈의 중간 변수
  PCt_0 = C_0 * P[0][0];
  PCt_1 = C_0 * P[1][0];
  //분모
  E = R_angle + C_0 * PCt_0;
  //게인 값
  K_0 = PCt_0 / E;
  K_1 = PCt_1 / E;
  
  t_0 = PCt_0;  //행렬 곱셈의 중간 변수
  t_1 = C_0 * P[0][1];
  
  P[0][0] -= K_0 * t_0;    //사후 추정 오차 공분산
  P[0][1] -= K_0 * t_1;
  P[1][0] -= K_1 * t_0;
  P[1][1] -= K_1 * t_1;
  
  q_bias += K_1 * angle_err;    //사후 추정
  angle_speed = gyro_m - q_bias;   //출력 값의 미분 값; 최적 각속도 작업
  angle += K_0 * angle_err; ////사후 추정; 최적 각도 작업
}
```

**테스트 결과**

밸런스 카를 잘 설치하고, 소스 코드를 업로드하고 전원을 켜세요; 슬라이드 스위치를 ON으로 설정하세요.

아두이노 IDE를 열고 보드레이트를 9600으로 설정하세요. 시리얼 모니터가 값을 팝업합니다.

![](media/11aa2cabab2af5ca81c489696100ffcf.png)

## 프로젝트 9: PID 원리

**설명:**

비례, 적분 및 미분은 선형으로 결합되어 제어 양을 형성하며, 제어 객체를 이 제어 양으로 제어합니다. 이러한 컨트롤러를 PID 컨트롤러라고 합니다.

아날로그 제어 시스템에서 컨트롤러의 가장 일반적인 제어 법칙은 PID 제어입니다.

**일반 아날로그 PID 제어 시스템의 블록 다이어그램은 아래에 표시됩니다.**

![](media/c94475c08788e733e7400057d2c753d1.png)

시스템은 아날로그 PID 컨트롤러와 제어되는 객체로 구성됩니다.

그림에서 **r(t)**는 주어진 값; **y(t)**는 시스템의 실제 출력 값;

제어 편차 **e(t)**는 주어진 값에서 실제 출력 값을 뺍니다.

$$
e(t) = r(t) − y(t)
$$
**e(t)**는 PID 제어의 입력;

**u(t)**는 PID 컨트롤러의 출력이자 제어되는 객체의 입력.

**따라서 아날로그 PID 컨트롤러의 제어 법칙은 다음과 같습니다:**

![](media/99cdbd2999397eeb77e86575d30b3f41.png)

**Kp:** 컨트롤러의 비례 계수;

**Ti:** 컨트롤러의 적분 시간, 적분 계수라고도 함;

**Td:** 컨트롤러의 미분 시간, 미분 계수라고도 함.

**(1) 비례 부분**

비례 부분의 수학 공식은: **Kp×e(t)**

아날로그 PID 컨트롤러에서 비례 링크는 편차 순간에 반응합니다.

편차가 발생하면 컨트롤러는 즉시 제어 동작을 생성하여 제어 양이 편차를 감소시키는 방향으로 변경되도록 합니다.

제어 강도는 비례 계수 **Kp**에 따라 다릅니다.

비례 계수 **Kp**가 클수록 제어 효과가 강해지고, 전이 과정이 빨라지고, 제어 과정의 정적 편차가 작아집니다.

그러나 **Kp**가 클수록 진동이 발생하기 쉽고 시스템 안정성을 파괴할 수 있습니다.

따라서 비례 계수 **Kp**의 선택은 적절해야 하며, 작은 전이 시간과 작은 안정 정적 차이를 달성해야 합니다.

**(2) 적분 부분**

적분 부분의 수학 공식은:

![](media/e0a17789364e36b86625dd1e17965eef.png)

적분 부분의 공식에서 편차가 있는 한 그 제어 효과는 계속 증가합니다.

편차 **e(t)=0**일 때만 적분이 상수가 되고 제어 효과가 증가하지 않습니다.

적분 링크의 조정 기능은 시스템의 정적 편차를 제거할 수 있음을 알 수 있습니다.

적분 링크는 시스템 응답 속도를 감소시키지만 시스템의 오버슈트를 증가시킵니다.

적분 계수 **Ti**가 클수록 적분 축적량이 약해집니다. 이 때 시스템은 전이 중에 진동하지 않습니다.

적분 계수 **Ti**를 증가시키면 정적 편차 제거 과정에 필요한 시간이 길어집니다; 그러나 오버슈트 양을 줄이고 시스템 안정성을 향상시킬 수 있습니다.

따라서 **Ti**는 실제 제어의 특정 요구 사항에 따라 결정되어야 합니다.

**(3) 미분 부분**

미분 부분의 수학 공식은:

![](media/7759577762ff26ecdc60051be97634eb.png)

정적 편차를 제거하는 것 외에도 실제 제어 시스템은 가속화된 조정 과정을 요구합니다.

편차가 발생하거나 편차 변화 순간에 (비례 링크의 역할) 즉각적인 응답뿐만 아니라 편차 값이 더 커지기 전에 적절한 수정을 제공해야 합니다.

이를 위해 미분 링크를 PI 컨트롤러에 추가하여 PID 컨트롤러를 형성할 수 있습니다.

미분 링크의 역할은 편차 변화에 대해 제어합니다. 편차가 빠르게 변할수록 PID 컨트롤러의 출력이 커지고, 편차 값이 더 커지기 전에 수정을 할 수 있습니다.

미분 동작을 도입하면 오버슈트를 줄이고 진동을 억제하며 시스템을 안정화시키는 데 도움이 됩니다. 특히 고차 시스템의 경우 시스템의 추적 속도를 가속화합니다.

그러나 미분의 효과는 입력 신호의 노이즈에 민감합니다.

노이즈가 높은 시스템의 경우 미분 신호를 사용하지 않거나 미분 동작 전에 입력 신호를 필터링하는 것이 좋습니다.

미분 부분의 효과는 미분 시간 상수 **Td**에 의해 결정됩니다.

**Td**가 클수록 편차 **e(t)**의 변동을 억제하는 효과가 강합니다;

**Td**가 작을수록 편차 **e(t)**에 대한 저항 효과가 약합니다.

미분 부분은 분명히 시스템 안정성에 큰 영향을 미칩니다.

적절한 미분 계수 **Td**를 선택하여 미분 동작을 최적화해야 합니다.

## 프로젝트 10: 직립 루프 조정

**설명:**

이전 프로젝트에서 PD를 사용하여 거의 수평면에서 카의 각도를 조정하여 밸런스를 맞추는 방법을 소개했습니다.

그러나 외부 힘에 의해 또는 경사면에서 카가 밸런스를 유지할 수 없습니다. 속도에 오류가 있기 때문입니다. 따라서 밸런스를 위해 카의 속도를 조정해야 합니다.

따라서 속도 측정 모듈이 필요합니다.

**우리가 사용한 모터에는 속도 측정을 위한 홀 인코더가 함께 제공됩니다.**

이전 레슨을 기반으로 속도를 조정하기 위해 PI (비례 및 적분)를 추가합니다. 이렇게 하면 경사면에서도 카가 밸런스를 유지할 수 있습니다.

여기 속도 루프는 양의 피드백입니다. 즉, 카가 뒤로 가고 있다면 카가 더 빠르게 앞으로 가는 것을 의미합니다.

구체적으로 손으로 카를 살짝 밀면 카의 바퀴가 밀리는 방향으로 가속되며, 즉 카가 기울어진 방향으로 가속됩니다. 그러면 카의 기울기 각도가 반대 방향으로 역전되며, 즉 밀리는 방향과 반대로 됩니다; 카가 기울어진 방향으로 가속되며 속도가 가속됩니다.

속도의 PI 조정은 이전에 생성된 기울기 각도를 오프셋하여 초기 평형점 근처로 돌아가며 떨어지지 않습니다.

**PI 규제의 원리와 기능:**

**PI_pwm = ki_speed \* (setp0 - positions) + kp_speed \* (setp0 - speeds_filter);** // 속도 루프 제어

비례 매개변수 **(** **kp_speed )**로 속도를 조정하여 카가 필요한 속도에 빠르게 접근하도록 합니다;

적분 매개변수 **(ki_speed)**로 속도 오류의 누적 값을 조정하여 정적 오류를 제거합니다.

![](media/06ad11db8db6c0c75411d8f6ccd38a4a.jpeg)

**예를 들어:**

물이 1미터 높이로 유지되는 물통이 있다고 가정합니다.

초기 물 높이가 0.2미터라고 가정하면 현재 물 높이와 목표 물 높이 사이에 오류가 있습니다. 오류는 0.8m입니다.

이 때 물 높이를 제어하기 위해 물을 추가한다고 가정합니다.

단순히 비례 제어 알고리즘을 사용하면 추가되는 물 양 **(u)**는 오류에 비례합니다. 즉, **u=kp\*error**

**kp=0.5**, **t=1** (첫 번째 물 추가), **u=0.5\*0.8=0.4**, 0.4m 물 양을 추가해야 합니다; 현재 물 높이는 **0.2m+0.4m=0.6m**가 됩니다.

그 다음 **t=2** (두 번째 물 추가), 물 높이 0.6m, 오류 0.4m, 추가해야 할 물 양 **u=0.5\*0.4=0.2 ;** 현재 물 높이는 **0.6m+0.2m=0.8m**가 됩니다.

계속 이 계산으로 물 높이가 1m에 도달합니다.

그러나 이러한 단일 비례 제어에는 몇 가지 단점이 있습니다. 그 중 하나는 – **정적 오류!**

위의 예에서 kp 값에 따라 시스템이 결국 1미터에 도달하지만 정적 오류 없이.

그러나 또 다른 상황을 고려합니다. 물통에 물이 새고 있다고 가정합니다. 매번 물을 추가할 때 0.1m 높이의 물이 누출된다고 가정합니다.

**kp=0.5**라고 가정하면 여러 번 물을 추가한 후 물통의 물 높이가 0.8m에 도달하고 더 이상 변하지 않습니다! 왜냐하면 물 높이가 0.8m일 때 **error =1-0.8=0.2m**이기 때문입니다.

따라서 물통에 추가되는 물 양은 **u=0.5\*0.2=0.1m**입니다.

동시에 물통에서 0.1m의 물이 매번 흘러나옵니다. 추가된 물이 누출된 물을 상쇄하므로 물 높이가 변하지 않습니다!

즉, 목표 물 높이는 1m이지만 시스템은 결국 0.8m에 도달하고 변하지 않습니다. 시스템이 안정에 도달했습니다. 결과 오류는 정적 오류입니다.

따라서 단일 비례 제어만으로는 많은 경우 요구 사항을 충족하지 않습니다. 적분 제어 알고리즘을 도입해야 합니다.

위의 예에서 개별 비례 제어만 사용할 때 시스템이 정적 오류에 갇히는 것을 찾을 수 있습니다. 그래서 적분 제어 알고리즘을 도입합니다.

제어에서 오류의 적분에 비례하는 구성 요소를 도입합니다.

**따라서 비례 + 적분 제어 알고리즘은:**

**u=kp\*error+ ki∗∫error**

여기서 다시 위의 예를 사용합니다.

첫 번째 오류는 0.8, 두 번째 오류는 0.4. 이 시점에서 오류의 적분 (이산의 경우 적분은 실제로 누적임)

![image-20230426164915487](media/image-20230426164915487.png)

이 시점의 제어 양은 비례 부분 외에 이 적분 항에 계수 **ki**를 곱한 부분도 있습니다.

이 적분 항이 이전 오류를 누적하기 때문에 정적 오류를 잘 제거할 수 있습니다.

(단순 비례 항만 있을 때 위의 예에서 시스템이 정적 오류에 갇히는 경우를 가정하면 적분 항의 추가로 인해 입력이 증가하여 물통의 물 높이가 0.8보다 커지고 점차 목표 1.0에 도달합니다.)

이것이 적분 항의 기능입니다.

**소스 코드:**

```c
#include <MsTimer2.h>        //내부 타이머 2
#include <PinChangeInt.h>    //이 라이브러리 파일은 UNO 보드의 모든 핀을 외부 인터럽트로 만들 수 있습니다.
#include <MPU6050.h>      //MPU6050 라이브러리
#include <Wire.h>        //IIC 라이브러리

MPU6050 mpu6050;     //MPU6050 객체 인스턴스화; 이름 mpu6050
int16_t ax, ay, az, gx, gy, gz;     //3축 가속도, 3축 자이로스코프 변수 정의

//TB6612 핀
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

///////////////////////angle parameters//////////////////////////////
float angle_X; //가속도로 X축의 기울기 각도 변수 계산
float angle_Y; //가속도로 Y축의 기울기 각도 변수 계산
float angle0 = 1; //실제 측정 각도 (이상적으로 0도)
float Gyro_x,Gyro_y,Gyro_z;  //자이로스코프로 각속도 계산
///////////////////////angle parameters//////////////////////////////

///////////////////////Kalman_Filter////////////////////////////
float Q_angle = 0.001;  //자이로스코프 노이즈 공분산
float Q_gyro = 0.003;    //자이로스코프 드리프트 노이즈 공분산
float R_angle = 0.5;    //가속도계 공분산
char C_0 = 1;
float dt = 0.005; //dt 값은 필터 샘플링 시간입니다.
float K1 = 0.05; //최적 추정의 편차를 계산하는 칼만 게인을 포함하는 함수입니다.
float K_0,K_1,t_0,t_1;
float angle_err;
float q_bias;    //자이로 드리프트

float accelz = 0;
float angle;
float angleY_one;
float angle_speed;

float Pdot[4] = { 0, 0, 0, 0};
float P[2][2] = {{ 1, 0 }, { 0, 1 }};
float  PCt_0, PCt_1, E;
//////////////////////Kalman_Filter/////////////////////////

//////////////////////PID parameters///////////////////////////////
double kp = 34, ki = 0, kd = 0.62;                   //각도 루프 매개변수
double kp_speed = 3.6, ki_speed = 0.080, kd_speed = 0;   //속도 루프 매개변수
double setp0 = 0; //각도 밸런스 포인트
int PD_pwm;  //각도 출력
float pwm1=0,pwm2=0;

//////////////////Interrupt speed measurement/////////////////////////////
#define PinA_left 5  //외부 인터럽트
#define PinA_right 4   //외부 인터럽트
volatile long count_right = 0;//홀 인코더로 계산된 펄스 값을 계산하는 데 사용 (volatile long 유형은 값이 유효하도록 보장)
volatile long count_left = 0;
int speedcc = 0;
//////////////////////pulse calculation/////////////////////////
int lz = 0;
int rz = 0;
int rpluse = 0;
int lpluse = 0;
int pulseright,pulseleft;
////////////////////////////////PI variable parameters//////////////////////////
float speeds_filterold=0;
float positions=0;
int flag1;
double PI_pwm;
int cc;
int speedout;
float speeds_filter;

void setup() 
{
  //모터의 핀을 OUTPUT으로 설정
  pinMode(right_R1,OUTPUT);       
  pinMode(right_R2,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(PWM_L,OUTPUT);

  //초기 상태 값 할당
  digitalWrite(right_R1,1);
  digitalWrite(right_R2,0);
  digitalWrite(left_L1,0);
  digitalWrite(left_L2,1);
  analogWrite(PWM_R,0);
  analogWrite(PWM_L,0);

  pinMode(PinA_left, INPUT);  //속도 코드 휠 입력
  pinMode(PinA_right, INPUT);

  //I2C 버스 가입
  Wire.begin();                            //I2C 버스 시퀀스 가입
  Serial.begin(9600);                       //시리얼 모니터 열기, 보드레이트 9600 설정
  delay(1500);
  mpu6050.initialize();                       //MPU6050 초기화
  delay(2);

  //5ms; 타이머2를 사용하여 타이머 인터럽트 설정 (참고：타이머2 사용은 핀3 핀11의 PWM 출력에 영향을 미침)
  MsTimer2::set(5, DSzhongduan);    //5ms ; DSzhongduan 함수를 한 번 실행
  MsTimer2::start();    //인터럽트 시작
}

void loop() 
{
  Serial.println(angle);
  delay(100);
  //Serial.println(PD_pwm);
  //Serial.println(pwm1);
  //Serial.println(pwm2);
  //Serial.print("pulseright = ");
  //Serial.println(pulseright);
  //Serial.print("pulseleft = ");
  //Serial.println(pulseleft);
  //Serial.println(PI_pwm);
  //Serial.println(speeds_filter);
  //Serial.println (positions);
  
  //5ms마다 바퀴 속도를 계산하는 외부 인터럽트
  attachPinChangeInterrupt(PinA_left, Code_left, CHANGE);          //PinA_left 레벨 변경 트리거 외부 인터럽트; 서브함수 Code_left 실행
  attachPinChangeInterrupt(PinA_right, Code_right, CHANGE);       //PinA_right 레벨 변경 트리거 외부 인터럽트; 서브함수 Code_right 실행
}

/////////////////////Hall calculation/////////////////////////
//왼쪽 속도 코드 휠 카운트
void Code_left() 
{
  count_left ++;
} 
//오른쪽 속도 코드 휠 카운트
void Code_right() 
{
  count_right ++;
} 
////////////////////pulse calculation///////////////////////
void countpluse()
{
  lz = count_left;     //코드 휠이 카운트한 값을 lz에 할당
  rz = count_right;

  count_left = 0;     //코드 카운터 클리어
  count_right = 0;

  lpluse = lz;
  rpluse = rz;

  if ((pwm1 < 0) && (pwm2 < 0))                     //이동 방향 판단; 뒤로（PWM, 즉 모터 전압이 음수）, 펄스 수는 음수
  {
    rpluse = -rpluse;
    lpluse = -lpluse;
  }
  else if ((pwm1 > 0) && (pwm2 > 0))                 //앞으로（PWM, 즉 모터 전압이 양수）, 펄스 수는 양수
  {
    rpluse = rpluse;
    lpluse = lpluse;
  }
  else if ((pwm1 < 0) && (pwm2 > 0))                 //카의 회전 방향 판단; 왼쪽으로 회전; 오른쪽 펄스 수는 양수; 왼쪽 펄스 수는 음수.
  {
    rpluse = rpluse;
    lpluse = -lpluse;
  }
  else if ((pwm1 > 0) && (pwm2 < 0))               //카의 회전 방향 판단; 오른쪽으로 회전; 오른쪽 펄스 수는 음수; 왼쪽 펄스 수는 양수.
  {
    rpluse = -rpluse;
    lpluse = lpluse;
  }

  //5ms마다 인터럽트 입력; 펄스 수 중첩
  pulseright += rpluse;
  pulseleft += lpluse;
}

/////////////////////////////////interrupts////////////////////////////
void DSzhongduan()
{
  sei();  //전체 인터럽트 허용
  countpluse();        //펄스 중첩 서브함수
  mpu6050.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);     //IIC로 MPU6050 6축 데이터 ax ay az gx gy gz 얻기
  angle_calculate(ax, ay, az, gx, gy, gz, dt, Q_angle, Q_gyro, R_angle, C_0, K1);      //각도와 칼만 필터링 얻기
  PD();         //각도 루프 PD 제어
  anglePWM();

  cc++;
  if(cc>=8)     //5*8=40，40ms마다 속도 PI 알고리즘 입력
  {
    speedpiout();   
    cc=0;  //클리어
  }
}
///////////////////////////////////////////////////////////

/////////////////////////////angle calculation///////////////////////
void angle_calculate(int16_t ax,int16_t ay,int16_t az,int16_t gx,int16_t gy,int16_t gz,float dt,float Q_angle,float Q_gyro,float R_angle,float C_0,float K1)
{
  float Angle = -atan2(ay , az) * (180/ PI);           //방사형 회전 각도 계산 공식; 음수 부호는 방향 처리
  Gyro_x = -gx / 131;              //자이로스코프로 계산된 X축 각속도; 음수 부호는 방향 처리
  Kalman_Filter(Angle, Gyro_x);            //칼만 필터링
  //회전 각도 Z축 매개변수
  Gyro_z = -gz / 131;                      //Z축 각속도
  //accelz = az / 16.4;

  float angleAx = -atan2(ax, az) * (180 / PI); //X축과의 각도 계산
  Gyro_y = -gy / 131.00; //Y축 각속도
  Yiorderfilter(angleAx, Gyro_y); //1차 필터링
}
////////////////////////////////////////////////////////////////

///////////////////////////////KalmanFilter/////////////////////
void Kalman_Filter(double angle_m, double gyro_m)
{
  angle += (gyro_m - q_bias) * dt;          //사전 추정
  angle_err = angle_m - angle;
  
  Pdot[0] = Q_angle - P[0][1] - P[1][0];    //방위각 오차 공분산 미분
  Pdot[1] = - P[1][1];
  Pdot[2] = - P[1][1];
  Pdot[3] = Q_gyro;
  
  P[0][0] += Pdot[0] * dt;    //사전 추정 오차 공분산 미분 적분
  P[0][1] += Pdot[1] * dt;
  P[1][0] += Pdot[2] * dt;
  P[1][1] += Pdot[3] * dt;
  
  //행렬 곱셈의 중간 변수
  PCt_0 = C_0 * P[0][0];
  PCt_1 = C_0 * P[1][0];
  //분모
  E = R_angle + C_0 * PCt_0;
  //게인 값
  K_0 = PCt_0 / E;
  K_1 = PCt_1 / E;
  
  t_0 = PCt_0;  //행렬 곱셈의 중간 변수
  t_1 = C_0 * P[0][1];
  
  P[0][0] -= K_0 * t_0;    //사후 추정 오차 공분산
  P[0][1] -= K_0 * t_1;
  P[1][0] -= K_1 * t_0;
  P[1][1] -= K_1 * t_1;
  
  q_bias += K_1 * angle_err;    //사후 추정
  angle_speed = gyro_m - q_bias;   //출력 값의 미분 값; 최적 각속도 작업
  angle += K_0 * angle_err; ////사후 추정; 최적 각도 작업
}

/////////////////////1차 필터링/////////////////
void Yiorderfilter(float angle_m, float gyro_m)
{
  angleY_one = K1 * angle_m + (1 - K1) * (angleY_one + gyro_m * dt);
}

//////////////////angle PD////////////////////
void PD()
{
  PD_pwm = kp * (angle + angle0) + kd * angle_speed; //PD 각도 루프 제어
}

//////////////////speed PI////////////////////
void speedpiout()
{
  float speeds = (pulseleft + pulseright) * 1.0;      //차량 속도  펄스 값
  pulseright = pulseleft = 0;      //클리어
  speeds_filterold *= 0.7;         //1차 보완 필터링
  speeds_filter = speeds_filterold + speeds * 0.3;
  speeds_filterold = speeds_filter;
  positions += speeds_filter;
  positions = constrain(positions, -3550,3550);    //적분 포화 방지
  PI_pwm = ki_speed * (setp0 - positions) + kp_speed * (setp0 - speeds_filter);      //속도 루프 제어 PI
}
//////////////////speed PI////////////////////


////////////////////////////PWM end value/////////////////////////////
void anglePWM()
{
  pwm2=-PD_pwm - PI_pwm ;           //최종 PWM 값을 모터에 할당
  pwm1=-PD_pwm - PI_pwm ;
  
  if(pwm1>255)             //PWM 값이 255보다 크지 않도록 제한
  {
    pwm1=255;
  }
  if(pwm1<-255) 
  {
    pwm1=-255;
  }
  if(pwm2>255)
  {
    pwm2=255;
  }
  if(pwm2<-255)
  {
    pwm2=-255;
  }

  if(angle>80 || angle<-80) //밸런스 카의 기울기 각도가 45°보다 크면 모터가 정지합니다.
  {
    pwm1=pwm2=0;
  }

 if(pwm2>=0)//PWM의 양수와 음수에 따라 모터의 방향과 속도를 결정
  {
    digitalWrite(left_L1,LOW);
    digitalWrite(left_L2,HIGH);
    analogWrite(PWM_L,pwm2);
  }
  else
  {
    digitalWrite(left_L1,HIGH);
    digitalWrite(left_L2,LOW);
    analogWrite(PWM_L,-pwm2);
  }

  if(pwm1>=0)
  {
    digitalWrite(right_R1,LOW);
    digitalWrite(right_R2,HIGH);
    analogWrite(PWM_R,pwm1);
  }
  else
  {
    digitalWrite(right_R1,HIGH);
    digitalWrite(right_R2,LOW);
    analogWrite(PWM_R,-pwm1);
  }
}
```

**테스트 결과**

밸런스 카를 잘 설치하고, 소스 코드를 업로드하고 전원을 켜세요; 전원 스위치를 ON으로 설정하세요.

밸런스 카가 책상 위에 똑바로 서 있습니다.

아두이노 IDE를 열고 보드레이트를 9600으로 설정하세요. 시리얼 모니터가 밸런스 카의 기울기 값을 팝업합니다.

![](media/f0773cc27ba2cb214458b74c9c06f7a4.png)

USB 케이블을 제거하고 밸런스 카를 바닥에 똑바로 세우세요.


# 2.Operation Principle

The self-balancing car uses the power of the car body to maintain the relative balance, which is a process of dynamic balance.

The power to maintain the balance of the car comes from the movement of the wheels, driven by two DC motors.

The control of the car body can be divided into three control tasks as follows:

**1. Balance Control:** keep the car upright and balanced by controlling the forward and backward rotation of the car’s wheel.

**2. Speed Control:** realize the front and rear movement and speed control by controlling the inclination of the car. In fact, it is achieved finally by controlling the speed of the motor.

**3. Direction Control:** realize the steering control by controlling the rotational speed differences between the two motors of the car.

In this way, it is relatively simple to understand the three control tasks.

But in the final control process, it comes down to the control of a control quantity. So there will be coupling between the three tasks, which will interfere with each other.

The key is to control the car’s balance; the speed and direction control should be as smooth as possible.

# 3.Parameters of balance car

**Motor parameters:**

Operating voltage: DC12V

Reduction ratio: 1:30

No-load current: ≤100mA

No-load speed: 247rpm

Rated torque: 1.4 Kg.cm

Rated torque: 137.3mN.m

Rated speed: 160rpm

Rated current: ≤0.45A

Stalled torque: 5.5 Kg.cm

Stop current: 2.4A

Reducer length: 22mm

Working voltage: DC 9-12V

Motor drive chip: TB6612FNG

Body posture detection: MPU-6050

Comes with power control switch

Comes with Bluetooth control switch for controlling serial communication

**Pay special attention to:**

The balance shield comes with a slide switch for controlling the Bluetooth communication.

When upload the source code, must turn the slide switch OFF; otherwise, code uploading will fail.

When connecting to the Bluetooth module, should turn the slide switch ON.

![](media/ca17b05327464d5ccfe69be52cd49bb6.png)

# 4.Kit List

The kit packaging contains all electronic components for this self-balancing car. As you work your way through each project, you will learn how to control the car.

| No.  | Component                                                    | Quantity |                           Picture                            |
| ---- | ------------------------------------------------------------ | -------- | :----------------------------------------------------------: |
| 1    | Dual-pass M3*45MM hex copper pillar                          | 4        | ![img](./media/wps1.png) |
| 2    | Dual-pass M3*10MM hex copper pillar                          | 4        | ![img](./media/wps22.png) |
| 3    | Black M4*6 cross screw                                       | 2        | ![img](./media/wps333.png) |
| 4    | M3*6MM round head screw                                      | 6        | ![img](./media/wps4.png) |
| 5    | M3*8MM round head screw                                      | 10       | ![img](./media/wps5.png) |
| 6    | M3*8MM flat head cross screw                                 | 4        | ![img](./media/wps6.png) |
| 7    | M3*12MM flat head cross screw                                | 2        | ![img](./media/wps7.png) |
| 8    | M3*12MM round head screw                                     | 10       | ![img](./media/wps8.png) |
| 9    | M3 nickel plating nut                                        | 12       | ![img](./media/wps9.png) |
| 10   | Acrylic plate pack of 2pcs                                   | 1        | ![img](./media/wps21.png) |
| 11   | Black+blue outer diameter 68mm thickness 26mm wheel          | 2        | ![img](./media/wps23.png) |
| 12   | DC gear motor with hall encoder 12V，1：30，                 | 2        | ![img](./media/wps24.png) |
| 13   | 6MM hole*18MM lengthCopper hex coupler                       | 2        | ![img](./media/wps25.png) |
| 14   | Double-head 6pin PH2.030CM connector wire                    | 2        | ![img](./media/wps26.png) |
| 15   | Yellow-black handle 3*40MM Phillips  screwdriver             | 1        | ![img](./media/wps28.png) |
| 16   | Type L M2 nickel plating inner hex wrench                    | 1        | ![img](./media/wps29.png) |
| 17   | 18650 3-cell AA battery+plug(18650 battery not included)     | 1        | ![img](./media/wps30.png) |
| 18   | Keyestudio Balance Shield V3 (black and eco-friendly)        | 1        | ![img](./media/wps31.png) |
| 19   | Keyestudio v4.0 Main Control Board                           | 1        | ![img](./media/wps32.jpeg) |
| 20   | AM/BM transparent blue OD:5.0 L=50cm  USB cable              | 1        | ![img](./media/wps33.png) |
| 21   | Keyestudio Bluetooth XBee HC-06                              | 1        | ![img](./media/wps34.png) |
| 22   | Motor iron holder                                            | 1        | ![img](./media/wps35.png) |
| 23   | Black winding tube                                           | 1        | ![img](./media/wps36.jpg)                   |

# 5.Assembly Steps

**⑴** Prepare all the components shown below

![](media/b5617b03012f591e915031216dafed40.jpeg)

![](media/93d98b25cca1a4818006f8a69d59e8ab.png)

**⑵** To begin with, we start to install the bottom Acrylic plate.

![](media/dec4c84f37e4ab50fecfea53373b6261.jpeg)

Find out the parts below:

-   Bottom Acrylic plate

-   Dual-pass M3\*10MM hex copper pillar x 4pcs

-   M3\*8MM screw x 4pcs

-   M3\*12MM flat head screw x 2pcs

-   M3 nickel plating nut x 2pcs

-   Battery case

We are now going to mount the battery case and copper pillars on the Acrylic plate.

Fix the 4pcs M3\*10MM copper pillar onto the Acrylic plate using 4pcs M3\*8MM screws.

![](media/ba542135eb736aa0edd7cab10139b8f1.jpeg)

Then Mount the battery case on the Acrylic plate using 2pcs M3\*12MM flat head screws and 2pcs M3 nickel plating Nuts.

![](media/9d62646249ba348a458b8ba00cd351dd.jpeg)

![](media/dfcb07bace0b5ba332bb9373a59e5142.jpeg)

**⑶** Next, move on to install the motor and wheel onto bottom Acrylic plate.

Find out the parts below:

-   Bottom Acrylic plate mounted with battery case
-   M3\*12MM round-head screw x 8pcs
-   M3 nickel plating nut x 8pcs
-   M4\*6MM black screw x 2pcs
-   Two wheels
-   Two black connectors
-   Two motors
-   Two copper hex couplers
-   M2 wrench Type L

![](media/381d37ae3bab9c04276f426f6a254f33.jpeg)



Go to mount the two black connectors onto the Acrylic plate using 8pcs M3\*12MM round-head screws and 8pcs M3 nickel plating nuts. Shown below.

![](media/5d79b03196991a5bb8f702e95b0cb9ad.jpeg)

Each motor is equipped with six screws in the bag. Go to mount the two motors on the black connectors using the screws.

![](media/fe987b19b5de94b5f264fa6d9a37b410.jpeg)

![](media/870d6c7b8bfa58b251a0c24c1b051e4e.jpeg)

Screw each copper hex couplers with two screws. Then fix the two copper couplers on the two motors using a wrench.

![](media/028702031b4e21b3871a4e2e4798927b.jpeg)



![](media/d213e3c8379078e2693e879c2793cdf1.jpeg)

Finally mount the two wheels to the two hex copper couplers using 2pcs M4\*6MM black screws.

![](media/3b6b8a394e30efc92cd1a0a9da7a3169.jpeg)

![](media/173a5e9757a5df4e9f146bf5fa31dbc8.jpeg)

![](media/ed6fbb3987cb766a9ffa0b70293ae7fc.jpeg)

Up to now, the bottom motor wheel are installed well!

**⑷** The final step is to install the control board and the top Acrylic plate.

![](media/b43ff4417ad0890b1ad8f8f198de7f24.jpeg)

-   Top Acrylic plate

-   V4.0 control board

-   keyestudio balance shield

-   Bluetooth XBee module HC-06

-   M3\*6MM round-head screw x 3pcs

-   M3\*45MM copper pillar x 4pcs

-   M3\*8MM round-head screw x 8pcs

-   6pin 30CM connector wire x 2pcs

Go to screw the V4.0 control board onto the 4pcs M3\*10MM copper pillars mounted on the Acrylic plate with 3pcs M3\*6MM round-head screws.

![](media/3b2b69724aeaaf40334572d46cb089a3.jpeg)

Then stack the keyestudio balance shield onto V4.0 control board. And plug the Bluetooth XBee module HC-06 into the balance shield.

![](media/1aa06f4d7152f9f9bfd865f79b7aad59.jpeg)

Go to connect the motor to the balance shield using 6pin PH2.0 30CM connector wire. Simply connect the motor to the nearest motor connector.

![](media/72513a28bc92107c9bae3e65a29db59b.jpeg)

![](media/b8368175fb4f0abb514ae7b1f5fe1911.jpeg)

After that, screw the 4pcs M3\*45MM copper pillars on the Acrylic plate with 4pcs M3\*8MM round head screws. And connect well the battery plug to DC black jack of V4.0.

![](media/542910ede8494a06a126a09104425817.jpeg)

The back view is showed below:

![](media/7bbab9da7f512230d481fda44886c5ce.jpeg)

The final part is to install the top Acrylic plate onto the 4pcs M3\*45MM copper pillars with 4pcs M3\*8MM round-head screws.

![](media/3465955d0c9cf3934abf5c22f6146ae4.jpeg)

Congrats! The balance car is installed well.

![](media/ed976d4f7f20a281b531b76a84cbf80A.jpg)

# 6.projects

## Project 1: Getting Started with Arduino

**The V4.0 Control Board**

When it comes to using the V4.0 as core of our robot, the V4.0 is the best board to get started with electronics and coding. If this is your first experience tinkering with the platform, the V4.0 is the most robust board you can start playing with.

![](media/88e350302076928641bee474abbfd7f3.jpeg)

Well, let's at first have a look at this V4.0 board.

![](media/709d9ef695f98e63ee0501030b455a69.jpeg)



**The Balance Car Shield**

The balance shield is an important part for this balance car. With it, you can DIY the balance car more simple.

It is fully compatible with V4.0 board; just stack it onto the control board. 

The balance shield comes with a 6612FNG chip for driving two DC motors; two white connectors for connecting DC motor; a DC power jack for powering on the shield and V4.0; 

Also comes with a large slide switch for controlling the power switch; a MPU-6050 for testing the posture; a XBEE Bluetooth interface for connecting Bluetooth module to communicate with Android devices; a small slide switch for controlling Bluetooth module’s communication; also comes with a button and an active buzzer. 

The control pins of V4.0 are all brought out as female header on the shield; the serial port and I2C communication pins are brought out as pin headers.

**Note:** connect the motor to the motor’s connector on the shield.

![image-20230510085238394](media/image-20230510085238394.png)

**PINOUT:**

![](media/e9497ec95579d3b4a2e863fc8ac7a24f.jpeg)

**Installing Arduino IDE**

![](/media/ide.png)

**Click the link to start learning how to download software, install drivers, upload code, and install library files.**

**[https://getting-started-with-arduino.readthedocs.io](https://getting-started-with-arduino.readthedocs.io/en/latest/Arduino%20IDE%20Tutorial.html)**

## Project 2: Button and Buzzer

**Description:**

In the previous project, you have learned how to use Arduino software environment.

Want to try it? Great. This project let’s get started with a basic program to enter the programming world of arduino.

![](media/4503905b43c71037a46a28ccd8efe8ee.jpeg)

The keyestudio balance car shield comes with a button KEY_13 and an active buzzer. To be specific, button is controlled by pin D13 on V4.0; active buzzer is controlled by pin D11 on V4.0.

![](media/ca17b05327464d5ccfe69be52cd49bb6.png)

In the experiment, we get down to controlling the buzzer with button. When press the button, the buzzer will sound.

![](media/f680ff553db7faf1f0b681fb2c8f6996.png)

The active buzzer comes with oscillating circuit. Actually, simple to set the pin D11 to HIGH, the buzzer can beep. We come to simulate the setting method of passive buzzer. Set different square wave to make the active buzzer output different sounds.

**Source Code:**

```c
const int buz = 11;    // set the buzzer pin 
const int btn = 13;    //set the button pin 
int button;    //button variable

void setup() 
{
  pinMode(btn,INPUT);       //set to INPUT state
  pinMode(buz,OUTPUT);       //set to OUTPUT state 
}

void loop() 
{
  button = digitalRead(btn);       //assign the button value to variable button
  if(button == 0)    //if press the button
  {
    delay(10);    //delay time 
    if(button == 0)     //judge again, if the button is pressed
    {
      buzzer();  // execute the subfunction of buzzer
    }
  }
  else        // button not pressed
  {
    digitalWrite(buz,LOW);    // buzzer not sounds
  }
}

//buzzer makes tick sound
void buzzer()      
{
    for(int i=0;i<50;i++)
    {
    digitalWrite(buz,HIGH);
    delay(1);
    digitalWrite(buz,LOW);
    delay(1);
    }
    delay(50);
    for(int i=0;i<50;i++)
    {
    digitalWrite(buz,HIGH);
    delay(1);
    digitalWrite(buz,LOW);
    delay(1);
    }
}
```

**Test Result**

Installed well the balance car, upload the source code and power on; turn the slide switch ON and then press the KEY_13 button on the shield.

The active buzzer on the balance shield will sound; otherwise, it will not sound.



## Project 3: TB6612 Motor Driving

**Description:**

We have tested the balance shield’s button and buzzer. Now, we are going to mainly test the motor driving ability.

In the project, we control the right motor’s direction by pin D8 D12 on V4.0; speed is controlled by pin D10. The left motor’s direction by pin D7 D6 on V4.0; speed is controlled by pin D9.

![](media/a6ae40878065311168a15a0ed46c607e.jpeg)

**The specified control method refers to the table below:**

| D8   | D12  | D10/PWM | Right motor | D7   | D6   | D9/PWM | Left motor |
|------|------|---------|-------------|------|------|--------|------------|
| HIGH | LOW  | 0-255   | Go front    | HIGH | LOW  | 0-255  | Go front   |
| LOW  | HIGH | 0-255   | Go back     | LOW  | HIGH | 0-255  | Go back    |
| HIGH | HIGH | /       | stop        | HIGH | HIGH | /      | stop       |
| LOW  | LOW  | /       | stop        | LOW  | LOW  | /      | stop       |

The D9 D10 are PWM pins, which can be used as Digital output or Analog output. 

If used as Analog output, it needs to call the analogWrite() function of ARDUINO, and this analogWrite() function can be controlled in the range of 0-255. 

A call to analogWrite() is on a scale of 0-255, such that analogWrite(255) requests a 100% duty cycle (always on), and analogWrite(127) is a 50% duty cycle (on half the time).

In the code, the greater the PWM value set by pin D9 and D10, the faster the two motors’ speed.

In the following, we only simply set the two motors to turn forward and backward.

**Source Code:**

```c
//TB6612 pins
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

void setup() 
{
  Serial.begin(9600);          //set the baud rate to 9600
  
  pinMode(right_R1,OUTPUT);     // set all TB6612pins to OUTPUT
  pinMode(right_R2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_L,OUTPUT);
}

void loop() 
{
  // two motors turn forward
  digitalWrite(right_R1,HIGH);
  digitalWrite(right_R2,LOW);
  digitalWrite(left_L1,HIGH);
  digitalWrite(left_L2,LOW);
  analogWrite(PWM_R,100);   // write into PWM value 0~255（speed）
  analogWrite(PWM_L,100);
}
```

**Test Result**

Installed well the balance car, upload the source code and power on; turn the slide switch ON.

Both left and right motors start to turn forward.

![](media/a6ae40878065311168a15a0ed46c607e.jpeg)



## Project 4: Hall Encoder Test

**Description:**

We have introduced how to set the speed of right and left motor by PWM value of D9 D10.

But how to get the specified speed? Well, we can test it using the motor’s built-in Hall encoder.

![](media/2c63ece82b926aa57e36a5d4f8a5b5e5.png)

![image-20230510090657965](media/image-20230510090657965.png)

In this project, you will learn how to calculate the specified speed by the number of pulses got from Hall encoder within 100ms.

**Source Code:**

```c
//TB6612 pins
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

const int PinA_left = 5;    // set the left motor’s pulse pin to D5
const int PinA_right = 4;    //set the right motor’s pulse pin to D4

int times=0,newtime=0,d_time=100;   // time, new time, time interval
int valA=0,valB=0,flagA=0,flagB=0;    //variable valA and valB for calculating the number of pulse

void setup() 
{
  Serial.begin(9600);
  
  pinMode(right_R1,OUTPUT);    // set the TB6612 pins to OUTPUT
  pinMode(right_R2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_L,OUTPUT);

  pinMode(PinA_left,INPUT);    // set the pulse pin to INPUT
  pinMode(PinA_right,INPUT);

}

void loop() 
{
  //both motors turn forward
  digitalWrite(right_R1,HIGH);
  digitalWrite(right_R2,LOW);
  digitalWrite(left_L1,HIGH);
  digitalWrite(left_L2,LOW);
  analogWrite(PWM_R,100);   //write into PWM value 0~255（speed）
  analogWrite(PWM_L,200);

  newtime=times=millis();     //make newtime and times equal to the time the program runs to here 
  while((newtime-times)<d_time)    //if less than the setting d_time，always loop
  {
    if(digitalRead(PinA_left)==HIGH&&flagA==0)   // if detects HIGH
    {
      valA++;      //valA plus 1
      flagA=1;
    }
    if(digitalRead(PinA_left)==LOW&&flagA==1)    // if LOW
    {
      valA++;     //valA plus 1
      flagA=0;
    }
    
    if(digitalRead(PinA_right)==HIGH&&flagB==0)
    {
      valB++;
      flagB=1;
    }
    if(digitalRead(PinA_right)==LOW&&flagB==1)
    {
      valB++;
      flagB=0;
    }
    newtime=millis();        //newtime equals to the time the program runs to here
  }
  Serial.println(valA);      // print out the value of valA and B
  Serial.println(valB);
  valA=valB=0;             //set to 0
}
```

**Test Result**

Installed well the balance car, upload the source code and power on; turn the slide switch ON.

Then open the Arduino IDE, set the baud rate to 9600, the serial monitor will pop up the number of pulse got from Hall encoder within 100ms ( correspond to left and right motor). 

See the figure below. 

![](media/d41314adde529353adc5efe78c535192.png)

## Project 5: Internal Timer Interrupt

**Description:**

In previous section, you have learned how to get the number of pulses by Hall encoder of motor within 100ms.  

Now, we will use the built-in internal timer (timer2) of V4.0 board. Calculate out the specified speed by the number of pulses got from Hall encoder within 100ms.

**Source Code:**

Before test the source code, do remember to add the corresponding library.

You can refer to the method in the link below:

<https://wiki.keyestudio.com/How_to_Install_Arduino_Library>

```c
#include <MsTimer2.h>

//TB6612 pins
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

const int PinA_left = 5;        //set the left motor’s pulse pin to D5
const int PinA_right = 4;       //set the right motor’s pulse pin to D4

int times=0,newtime=0,d_time=100;   // time, new time, time interval
int valA=0,valB=0,flagA=0,flagB=0;   //variable valA and valB for calculating the number of pulse

void setup() 
{
  Serial.begin(9600);
  
  pinMode(right_R1,OUTPUT);     //set the TB6612 pins to OUTPUT
  pinMode(right_R2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_L,OUTPUT);

  pinMode(PinA_left,INPUT);      // set the pulse pin to INPUT
  pinMode(PinA_right,INPUT);
  
  MsTimer2::set(100, inter); // trigger an interrupt per 100ms 
  MsTimer2::start();    // start interrupt
}

void loop() 
{
  //both motors turn forward
  digitalWrite(right_R1,HIGH);
  digitalWrite(right_R2,LOW);
  digitalWrite(left_L1,HIGH);
  digitalWrite(left_L2,LOW);
  analogWrite(PWM_R,100);    //write into PWM value 0~255（speed）
  analogWrite(PWM_L,200);

  if(digitalRead(PinA_left)==HIGH&&flagA==0)     // calculate the pulse value
    {
      valA++;
      flagA=1;
    }
    if(digitalRead(PinA_left)==LOW&&flagA==1)
    {
      valA++;
      flagA=0;
    }
    
    if(digitalRead(PinA_right)==HIGH&&flagB==0)
    {
      valB++;
      flagB=1;
    }
    if(digitalRead(PinA_right)==LOW&&flagB==1)
    {
      valB++;
      flagB=0;
    }
    
}

//interrupt function
void inter()    
{
    sei();    //allow whole interrupts
    Serial.print("valA = ");     //print out the pulse value on serial monitor
    Serial.println(valA);
    Serial.print("valB = ");
    Serial.println(valB);
    valA = valB = 0;
}
```

**Test Result**

Installed well the balance car, power on and upload the source code to the board;

Turn the slide switch ON.

Then open the monitor of Arduino IDE, set the baud rate to 9600,.

The serial monitor will pop up the number of pulse got from Hall encoder within 100ms ( correspond to left and right motor).

See the figure below.

![](media/41e4099873055457571d638252b9c665.png)



## Project 6: Bluetooth Test

**Description:**

![](media/949c3308572221676761f2f9afe9bf68.png)

The kit contains a Bluetooth XBee module, which is compatible with Android system.

Keyestudio Bluetooth XBee wireless module HC-06 has features of compact size, compatible with XBEE shield, and suitable for various 3.3V MCU systems. It also comes with efficient on-board antenna.

More contents check the link here.

<https://wiki.keyestudio.com/Ks0144_keyestudio_XBee_Bluetooth_Wireless_Module_HC-06>

In this project, go to learn how to use Bluetooth APP to make the balance car communicate with Android Bluetooth. You are able to use Bluetooth APP to randomly control the balance car move.

![](media/e43a43d30d7fa6c0b880a55872573b4b.jpeg)

**Note:**

The keyestudio balance shield comes with a slide switch for controlling the Bluetooth communication.

When upload the source code, must turn the switch OFF; or else code uploading fails.

When connect to the Bluetooth module, should turn the switch ON.

**How to use Bluetooth APP?**

-   Installed the balance car, upload the source code and power on; turn the power switch ON; turn the Bluetooth switch ON.
    
-   Install the Bluetooth APP, then you can see the icon below on your phone.

![image-20230510091355397](media/image-20230510091355397.png)

Click the link below to download the APP:

<https://drive.google.com/open?id=1L69xdfmOvfhg0Wjh_p2FrtRkhs1h0fEu>

-   Tap to open the Bluetooth APP; you will see the interface shown below.

![](media/c9025f5cc50b1c07224b747d3b8a75c8.png)

![](media/1f4c2a18315a5113785e94e790e7c6e8.png)

-   Tap the Bluetooth icon![image-20230426163821621](media/image-20230426163821621.png); enter
    the Bluetooth search and pairing interface shown below.

![image-20230510091436455](media/image-20230510091436455.png)

-   Tap the HC-06 (search at the first time is a address, so tap the address); the PIN is 1234.

![image-20230510091459462](media/image-20230510091459462.png)

-   Finally you will see the paired device.

![image-20230510091516036](media/image-20230510091516036.png)

-   Connected HC-06 on your phone; now go to tap the Bluetooth connection icon ![image-20230426163848425](media/image-20230426163848425.png) on APP. 

![](media/b3fdf12f728b45fd74de8911e22a0a36.png)

-   Then tap the![image-20230426163912972](media/image-20230426163912972.png) showed on the APP. Up to now, the Bluetooth should connect successfully.
-   Bluetooth connected, tap the key ![image-20230426163936649](media/image-20230426163936649.png), the two motors of balance car turn forward;
-   tap the key![image-20230426163944987](media/image-20230426163944987.png), the two motors of balance car stop;  
-   tap the key![image-20230426163957010](media/image-20230426163957010.png), the two motors of balance car turn backward.

**Source Code:**

```c
//TB6612 pins
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;
char val;   // Bluetooth variable

void setup() 
{
  Serial.begin(9600);
  
  pinMode(right_R1,OUTPUT);   //set TB6612 pins OUTPUT
  pinMode(right_R2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_L,OUTPUT);
}

void loop() 
{
  if(Serial.available())    //if serial buffer value is available
  {
    val = Serial.read();      //assign the value read from serial port to val
    Serial.println(val);
    switch(val)             //switch statement
    {
      case 'F': front(); break;     //motor turns front
      case 'B': back(); break;       //turn back
      case 'S': Stop();break;    //stop
    }
  }
}

//turn front
void front()
{
  digitalWrite(right_R1,HIGH);
  digitalWrite(right_R2,LOW);
  digitalWrite(left_L1,HIGH);
  digitalWrite(left_L2,LOW);
  analogWrite(PWM_R,100);
  analogWrite(PWM_L,100);
}
//turn back
void back()
{
  digitalWrite(right_R1,LOW);
  digitalWrite(right_R2,HIGH);
  digitalWrite(left_L1,LOW);
  digitalWrite(left_L2,HIGH);
  analogWrite(PWM_R,100);
  analogWrite(PWM_L,100);
}
//stop
void Stop()
{
  digitalWrite(right_R1,LOW);
  digitalWrite(right_R2,HIGH);
  digitalWrite(left_L1,LOW);
  digitalWrite(left_L2,HIGH);
  analogWrite(PWM_R,0);
  analogWrite(PWM_L,0);
}
```

## Project 7: MPU6050 Test

**Description:**

When DIY the balance car, should obtain its posture at first. The most used is through accelerometer and gyroscope. 

In theory, only need two-axis accelerometer (Z-axis in the straight direction and the Y-axis along the moving direction of the car) and a single-axis gyroscope (the angular velocity in the X-axis direction of the car wheel are calculated). 

![image-20230510091703291](media/image-20230510091703291.png)

In this project, we use the built-in MPU-6050 chip of keyestudio balance shield to test the data of the three-axis accelerometer and the three-axis gyroscope, printing out it on the serial monitor.

The acceleration range is +-2g; the gyroscope range is +-250°/S.

**Source Code:**

```c
#include <Wire.h>
 
long accelX, accelY, accelZ;      // set to overall variable; can be used directly inside the function.
float gForceX, gForceY, gForceZ;
 
long gyroX, gyroY, gyroZ;
float rotX, rotY, rotZ;
 
void setup() {
  Serial.begin(9600);
  Wire.begin();
  setupMPU();
}
 
void loop() {
  recordAccelRegisters();
  recordGyroRegisters();
  printData();
  delay(100);
}
 
void setupMPU(){
  // REGISTER 0x6B/REGISTER 107:Power Management 1
  Wire.beginTransmission(0b1101000); //This is the I2C address of the MPU (b1101000/b1101001 for AC0 low/high datasheet Sec. 9.2)
  Wire.write(0x6B); //Accessing the register 6B/107 - Power Management (Sec. 4.30) 
  Wire.write(0b00000000); //Setting SLEEP register to 0, using the internal 8 Mhz oscillator
  Wire.endTransmission();
 
  // REGISTER 0x1b/REGISTER 27:Gyroscope Configuration
  Wire.beginTransmission(0b1101000); //I2C address of the MPU
  Wire.write(0x1B); //Accessing the register 1B - Gyroscope Configuration (Sec. 4.4) 
  Wire.write(0x00000000); //Setting the gyro to full scale +/- 250deg./s (转化为rpm:250/360 * 60 = 41.67rpm) ;The highest can be converted to 2000deg./s 
  Wire.endTransmission();
  
  // REGISTER 0x1C/REGISTER 28:ACCELEROMETER CONFIGURATION
  Wire.beginTransmission(0b1101000); //I2C address of the MPU
  Wire.write(0x1C); //Accessing the register 1C - Acccelerometer Configuration (Sec. 4.5) 
  Wire.write(0b00000000); //Setting the accel to +/- 2g（if choose +/- 16g，the value would be 0b00011000）
  Wire.endTransmission(); 
}
 
void recordAccelRegisters() {
  // REGISTER 0x3B~0x40/REGISTER 59~64
  Wire.beginTransmission(0b1101000); //I2C address of the MPU
  Wire.write(0x3B); //Starting register for Accel Readings
  Wire.endTransmission();
  Wire.requestFrom(0b1101000,6); //Request Accel Registers (3B - 40)
 
  // Use left shift << and bit operations |  Wire.read() read once 1bytes，and automatically read the data of the next address on the next call.
  while(Wire.available() < 6);  // Waiting for all the 6 bytes data to be sent from the slave machine （Must wait for all data to be stored in the buffer before reading） 
  accelX = Wire.read()<<8|Wire.read(); //Store first two bytes into accelX （Automatically stored as a defined long value）
  accelY = Wire.read()<<8|Wire.read(); //Store middle two bytes into accelY
  accelZ = Wire.read()<<8|Wire.read(); //Store last two bytes into accelZ
  processAccelData();
}
 
void processAccelData(){
  gForceX = accelX / 16384.0;     //float = long / float
  gForceY = accelY / 16384.0; 
  gForceZ = accelZ / 16384.0;
}
 
void recordGyroRegisters() 
{
  // REGISTER 0x43~0x48/REGISTER 67~72
  Wire.beginTransmission(0b1101000); //I2C address of the MPU
  Wire.write(0x43); //Starting register for Gyro Readings
  Wire.endTransmission();
  Wire.requestFrom(0b1101000,6); //Request Gyro Registers (43 ~ 48)
  while(Wire.available() < 6);
  gyroX = Wire.read()<<8|Wire.read(); //Store first two bytes into accelX
  gyroY = Wire.read()<<8|Wire.read(); //Store middle two bytes into accelY
  gyroZ = Wire.read()<<8|Wire.read(); //Store last two bytes into accelZ
  processGyroData();
}
 
void processGyroData() {
  rotX = gyroX / 131.0;
  rotY = gyroY / 131.0; 
  rotZ = gyroZ / 131.0;
}
 
void printData() {
  Serial.print("Gyro (deg)");
  Serial.print(" X=");
  Serial.print(rotX);
  Serial.print(" Y=");
  Serial.print(rotY);
  Serial.print(" Z=");
  Serial.print(rotZ);
  Serial.print(" Accel (g)");
  Serial.print(" X=");
  Serial.print(gForceX);
  Serial.print(" Y=");
  Serial.print(gForceY);
  Serial.print(" Z=");
  Serial.println(gForceZ);
}
```

**Test Result**

Installed well the balance car, upload the source code and power on; turn the slide switch ON.

Then open the Arduino IDE, set the baud rate to 9600, the serial monitor will pop up the value.

![](media/d868cb52acefe42eec83c99967b0f7f3.png)

## Project 8: Calculating Inclined Angle And Angular Velocity Values

**Description:**

In the previous project, we have used accelerometer and gyroscope to get the car’s posture. 

In this lesson, we use the data measured by MPU-6050 chip to directly get the posture of balance car. 

You will learn how to calculate the tilt angle and angular velocity value detected by balance car. Show the test result on the serial monitor. 

**Source Code:**

**Note:**

Before test the source code, do remember to add the corresponding library.

You can refer to the method in the link below:

<https://wiki.keyestudio.com/How_to_Install_Arduino_Library>

```c
#include <MPU6050.h>      //MPU6050 library
#include <Wire.h>        //IIC communication library

MPU6050 mpu6050;     //Instantiate an MPU6050 object; name mpu6050
int16_t ax, ay, az, gx, gy, gz;     //Define three-axis acceleration, three-axis gyroscope variables

float Angle;   //angle variable
int16_t Gyro_x;   //Angular velocity variable

void setup() 
{
  // Join the I2C bus
  Wire.begin();                            //Join the I2C bus sequence
  Serial.begin(9600);                       //open serial monitor and set the baud rate to 9600
  delay(1500);
  mpu6050.initialize();                       //initialize MPU6050
  delay(2);
}

void loop() 
{
  mpu6050.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);     //IIC to get MPU6050 six-axis data  ax ay az gx gy gz
  Angle = -atan2(ay , az) * (180/ PI);           //Radial rotation angle calculation formula; the negative sign is direction processing
  Gyro_x = -gx / 131;              //The X-axis angular velocity calculated by the gyroscope; the negative sign is the direction processing
  Serial.print("Angle = ");
  Serial.print(Angle);
  Serial.print("   Gyro_x = ");
  Serial.println(Gyro_x);
}
```

**Test Result**

Installed well the balance car, upload the source code and power on; turn the slide switch ON.

Then open the Arduino IDE, set the baud rate to 9600, the serial monitor will pop up the value.

![](media/6c828cc1a4d67fcc4ab5d7ea62c76cf3.png)

**How to use Kalman filtering to calculate the angel?**

**What’s Kalman filtering ?**

Kalman filtering is an algorithm that uses the linear system state equation to estimate the state of the system through the input and output of the system.

Since the observed data includes the effects of noise and interference in the system, the optimal estimate can also be seen as a filtering process.

![](media/0bb60c33d5b04090245004b5623b884e.jpeg)

Accelerometer data cannot always be trusted 100% due to original data acquired by the MPU6050. **Why?**

The accelerometer measures the inertial force, which may be caused by gravitational force (ideally only gravitational), but it may also be caused by the acceleration (motion) of the device. 

Therefore, even if the accelerometer is in a relatively stable state, it is still very sensitive to vibration and mechanical noise. 

That is, the individual number of inclination angles obtained by using the value of the 3-axis acceleration is erroneous, and the error is large. Then you need to use a gyroscope to eliminate any accelerometer errors.

**But how is this done? Is there no noise in the gyroscope?**

The gyroscope is not without noise, but because it measures rotation, it is less sensitive to linear mechanical motion (the type of noise the accelerometer is subjected to). 

However, the gyroscope has other types of problems, such as drift (does not return to zero rate values when the rotation stops). 

Nonetheless, by averaging the data from the accelerometer and the gyroscope, we can obtain a better estimate than the current device’s tilt angle obtained by using the accelerometer data alone.

Therefore, in order to obtain a smaller, more stable angle, we need to perform Kalman filtering on the inclination angle ![image-20230426164223743](media/image-20230426164223743.png)calculated by the acceleration and the measured angular velocity value ![image-20230426164236229](media/image-20230426164236229.png) of the gyroscope.

In this project，we use Kalman filter to calculate the balance angle and angular velocity of the balance car, displaying the tested data on the serial monitor.

**Source Code:**

**Note:**

Before test the source code, do remember to add the corresponding library.

You can refer to the method in the link below:

<https://wiki.keyestudio.com/How_to_Install_Arduino_Library>

```c
#include <MPU6050.h>      //MPU6050 library
#include <Wire.h>        //IIC communication library

MPU6050 mpu6050;     //Instantiate an MPU6050 object; name mpu60500
int16_t ax, ay, az, gx, gy, gz;     //Define three-axis acceleration, three-axis gyroscope variables
float Angle;
float Gyro_x,Gyro_y,Gyro_z;  //calculate angular velocity of each axis by gyroscope 

///////////////////////Kalman_Filter////////////////////////////
float Q_angle = 0.001;  //Covariance of gyroscope noise
float Q_gyro = 0.003;    //Covariance of gyroscope drift noise
float R_angle = 0.5;    //Covariance of accelerometer
char C_0 = 1;
float dt = 0.005; //The value of dt is the filter sampling time.
float K1 = 0.05; // a function containing the Kalman gain is used to calculate the deviation of the optimal estimate.
float K_0,K_1,t_0,t_1;
float angle_err;
float q_bias;    //gyroscope drift 

float accelz = 0;
float angle;
float angle_speed;

float Pdot[4] = { 0, 0, 0, 0};
float P[2][2] = {{ 1, 0 }, { 0, 1 }};
float  PCt_0, PCt_1, E;

//////////////////////Kalman_Filter/////////////////////////
void setup() 
{
  // Join the I2C bus 
  Wire.begin();                            //Join the I2C bus sequence
  Serial.begin(9600);                       //open serial monitor and set the baud rate to 9600
  delay(1500);
  mpu6050.initialize();                       //initialize MPU6050
  delay(2);
}

void loop() 
{
  Serial.print("Angle = ");
  Serial.print(Angle);
  Serial.print("  K_angle = ");
  Serial.println(angle);
  Serial.print("Gyro_x = ");
  Serial.print(Gyro_x);
  Serial.print("  K_Gyro_x = ");
  Serial.println(angle_speed);

  mpu6050.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);     //IIC to get MPU6050 six-axis ax ay az gx gy gz
  angle_calculate(ax, ay, az, gx, gy, gz, dt, Q_angle, Q_gyro, R_angle, C_0, K1);      //obtain angle and KalmanFilter 
}

/////////////////////////////angle calculate///////////////////////
void angle_calculate(int16_t ax,int16_t ay,int16_t az,int16_t gx,int16_t gy,int16_t gz,float dt,float Q_angle,float Q_gyro,float R_angle,float C_0,float K1)
{
  Angle = -atan2(ay , az) * (180/ PI);           //Radial rotation angle calculation formula; negative sign is direction processing
  Gyro_x = -gx / 131;              //The X-axis angular velocity calculated by the gyroscope; the negative sign is the direction processing
  Kalman_Filter(Angle, Gyro_x);            //KalmanFilter 
}

///////////////////////////////KalmanFilter/////////////////////
void Kalman_Filter(double angle_m, double gyro_m)
{
  angle += (gyro_m - q_bias) * dt;          //Prior estimate
  angle_err = angle_m - angle;
  
  Pdot[0] = Q_angle - P[0][1] - P[1][0];    //Differential of azimuth error covariance
  Pdot[1] = - P[1][1];
  Pdot[2] = - P[1][1];
  Pdot[3] = Q_gyro;
  
  P[0][0] += Pdot[0] * dt;    //The integral of the covariance differential of the prior estimate error
  P[0][1] += Pdot[1] * dt;
  P[1][0] += Pdot[2] * dt;
  P[1][1] += Pdot[3] * dt;
  
  //Intermediate variable of matrix multiplication
  PCt_0 = C_0 * P[0][0];
  PCt_1 = C_0 * P[1][0];
  //Denominator
  E = R_angle + C_0 * PCt_0;
  //Gain value
  K_0 = PCt_0 / E;
  K_1 = PCt_1 / E;
  
  t_0 = PCt_0;  //Intermediate variable of matrix multiplication
  t_1 = C_0 * P[0][1];
  
  P[0][0] -= K_0 * t_0;    //Posterior estimation error covariance 
  P[0][1] -= K_0 * t_1;
  P[1][0] -= K_1 * t_0;
  P[1][1] -= K_1 * t_1;
  
  q_bias += K_1 * angle_err;    //Posterior estimation
  angle_speed = gyro_m - q_bias;   //The differential value of the output value; work out the optimal angular velocity
  angle += K_0 * angle_err; ////Posterior estimation; work out the optimal angle
}
```

**Test Result**

Installed well the balance car, upload the source code and power on; turn the slide switch ON.

Then open the Arduino IDE, set the baud rate to 9600, the serial monitor will pop up the value.

![](media/11aa2cabab2af5ca81c489696100ffcf.png)



## Project 9: PID Principle

**Description:**

The Proportion of deviation, Integral and the Differential are linearly combined to form a control quantity, then control object by this control quantity. Such a controller is called a PID controller.

In analog control systems, the most common control law for controllers is PID control.

**The block diagram of the common analog PID control system is shown below.**

![](media/c94475c08788e733e7400057d2c753d1.png)

The system consists of an analog PID controller and a controlled object.

In the figure, **r(t)** is a given value; **y(t)** is the actual output value of the system;

control deviation **e(t)** equals the given value subtracts the actual output value.

$$
e(t) = r(t) − y(t)
$$
**e(t)** is the input of the PID control; 

**u(t)** is used as the output of the PID controller and the input of the controlled object.

**So the control law of the analog PID controller is follows:**

![](media/99cdbd2999397eeb77e86575d30b3f41.png)

**Kp:** the proportional coefficient of the controller;

**Ti** : the integral time of the controller, also called the integral coefficient;

**Td** : the differential time of the controller, also called the differential coefficient.

**(1) Proportion part**

The mathematical formula of the proportional part is: **Kp×e(t)**

In the analog PID controller, the proportional link is to react to the moment of deviation.

Once the deviation occurs, the controller immediately produces a control action
that causes the control amount to change in the direction of decreasing the
deviation.

The strength of the control depends on the proportional coefficient **Kp**.

The larger the proportional coefficient **Kp**, the stronger the control effect, the faster the transition process, the smaller the static deviation of the control process.

However, the larger the **Kp**, the more likely it is to oscillate and to destroy the system stability.

Therefore, the selection of the proportional coefficient **Kp** must be appropriate to achieve a small transition time and a small and stable static difference.

**(2) Integral part**

The mathematical formula of the integral part is:

![](media/e0a17789364e36b86625dd1e17965eef.png)

From the formula of the integral part, we can know that as long as there is a deviation, its control effect will continue to increase.

Only when the deviation **e(t)=0**, its integral can be a constant, and the control effect is not a Increased constant.

It can be seen that the integral part can eliminate the deviation of the system.

Although the adjustment function of the integral link will eliminate the static error, it will reduce the response speed of the system and increase the overshoot of the system.

The larger the integral constant **Ti** is, the weaker the accumulation of the integral is. At this time, the system does not oscillate during the transition.

Increasing the integral constant **Ti** can slow down the elimination process of the static error, and the time required to eliminate the deviation is also longer; however, can reduce the amount of overshoot and improve the stability of the system.

When **Ti** is small, the integral action is strong; oscillation may occur during the system transition time, but the time required to eliminate the deviation is short. Therefore, **Ti** must be determined according to the specific requirements of actual control.

**(3) Differential part**

The mathematical formula of the differential part is:

![](media/7759577762ff26ecdc60051be97634eb.png)

In addition to the desire to eliminate static errors, the actual control system requires an accelerated adjustment process. 

At the moment when the deviation occurs, or at the moment of the deviation change, not only the immediate response (the role of the proportional link ) is required, but also the appropriate correction is given in advance according to the trend of the deviation. 

In order to achieve this, a differential link can be added to the PI controller to form a PID controller.

The role of the differential link is to prevent changes in the deviation. It is controlled according to the trend of change (speed of change). 

The faster the deviation changes, the larger the output of the differential controller, and the correction can be made before the deviation value becomes larger. 

The introduction of differential action will help to reduce the overshoot, overcome the oscillation, and stabilize the system, especially for the high-order system, which speeds up the tracking speed of the system. 

However, the effect of differentiation is sensitive to the noise of the input signal. 

For those systems with higher noise, the differential signal is generally not used, or the input signal is filtered before the differential action. 

The effect of the differential portion is determined by the differential time constant **Td**

The larger the **Td**, the stronger the effect of suppressing the variation of the deviation **e(t)**;

The smaller the **Td**, the weaker the effect of its resistance to the deviation **e(t)**.

The differential part obviously has a great effect on the stability of the system.

By appropriately selecting the differential constant **Td**, the differential action can be optimized.



## Project 10: Upright Loop Adjustment

**Description:**

In the previous project, we have introduced how to use MPU-6050 chip to calculate the inclined angle and angular velocity value so as to control the car’s balance.

In this section, we will set about to balance the car upright on a horizontal plane via PD (**proportion** and **differential** ).

However, if placed on a slope or pushed slightly by hand, the car will accelerate in the inclined direction and fall down.

The corresponding inclined angle value can be printed out on the serial monitor.

![](media/9291c8c0883d2c667481d3f303a8cbef.jpeg)

**Upright balance principle:**

The self-balancing robot stands upright on two coaxial wheels. 

The gravity center of robot’s structure design is not on the axis center of the two coaxial wheels and the air flow effect, it will fall in one direction when standing.

To prevent the robot from falling down, it is necessary to add a suitable opposite direction force in the falling direction. 

This suitable reverse direction force is provided by a DC geared motor that drives two wheels.

**How does a gear DC motor provide a reverse force?**

The connection between the self-balancing robot body and the wheels is equivalent to a hinge. Figure below is a simplified diagram of a self-balancing robot.

![](media/a9bc90bbb9c6cf75bb92436414100aa9.png)

If the wheel accelerates to the right, due to the effect of inertia, the center of gravity of the body will be subjected to a leftward **inertial force F**.

Just like on the car, if the car accelerates, the person on the car will lean backwards.

**But how big is the force in the opposite direction?**

Now we come to analyze the force of the self-balancing robot body at an **oblique angle θ**.

![](media/8e242856339e70764e16824568833d54.png)

From the force analysis, we can get the Force balance equation below：

![](media/b4ee374719e905b23f3dbe7ed2ce1739.png)

So can turn into the restoring force of robot:

![](media/3203237342b089c73b09ac326ef65d4b.png)

From the force balance equation, the reverse direction force is determined by the acceleration **a** of the wheel; the magnitude of the acceleration **a** is determined by the inclination angle **θ** of the robot body.

Thus, if we know the angle of the inclination angle **θ**, and then control the value of the acceleration **a** according to the magnitude of **θ**;

It seems that the self-balancing robot will not fall down, that is, a negative feedback control.

However, it is difficult for the robot to stand upright and stably through simply adjusting the acceleration **a** by the inclination angle **θ**.

Because the value of **a** is difficult to adjust to the exact value, which is often greater than the appropriate value. So the robot tends to the other direction, swing back and fort in the vertical position, with a larger amplitude.

To stabilize the robot return to the vertical position as soon as possible, you need to increase the damping force.

Supposed that the negative feedback control is that the wheel acceleration **a** is proportional to the inclination angle **θ**, and the ratio is **k1.** That is: ![](media/ed54899164059192f3f3a68b7c99c27f.png)

Linearize the formula: ![](media/3203237342b089c73b09ac326ef65d4b.png)

because the inclination angle **θ** is relatively small, get: ![](media/18e0922e6c6c4d21b3c4f0de8eabedac.png) ; ![](media/7237fbe5cd7a2083fe120f9e5afddced.png) ;

![](media/9f2e2832916c29d0ccfeb0a15ddccdfd.png)

The increased damping force is proportional to the speed of the declination;

The factor of proportionality is **k2**, and the direction is opposite.

Then change the formula into: ![](media/345bc87e43bdfca330a857e06e731c0c.png)

Then can get the final arithmetic of wheel acceleration **a**: **![](media/750040922147fffea519b130bad831ea.png)**

**θ:** inclination angle **θ':** angle speed

**K1; k2:** the factor of proportionality. It is also Kp and Kd in the PD algorithm adjustment of the robot upright balance described later.

Up to now, in theory, the balance robot can be balanced upright.

**Source Code:**

```c
#include <MsTimer2.h>        //internal timer 2
#include <PinChangeInt.h>    //this library can make all pins of arduino UNO as external interrupt
#include <MPU6050.h>      //MPU6050 library 
#include <Wire.h>        //IIC communication library 

MPU6050 mpu6050;     //Instantiate an MPU6050 object; name mpu6050
int16_t ax, ay, az, gx, gy, gz;     //Instantiate an MPU6050 object; name mpu6050

//TB6612 pins
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

///////////////////////angle parameters//////////////////////////////
float Angle;
float angle_X; //calculate the inclined angle variable of X-axis by accelerometer
float angle_Y; //calculate the inclined angle variable of Y-axis by accelerometer
float angle0 = 1; //Actual measured angle (ideally 0 degrees) 
float Gyro_x,Gyro_y,Gyro_z;  //Angular angular velocity for gyroscope calculation
///////////////////////angle parameters//////////////////////////////

///////////////////////Kalman_Filter////////////////////////////
float Q_angle = 0.001;  //Covariance of gyroscope noise
float Q_gyro = 0.003;    //Covariance of gyroscope drift noise
float R_angle = 0.5;    //Covariance of accelerometer
char C_0 = 1;
float dt = 0.005; // The value of dt is the filter sampling time.
float K1 = 0.05; // a function containing the Kalman gain is used to calculate the deviation of the optimal estimate
float K_0,K_1,t_0,t_1;
float angle_err;
float q_bias;    //gyroscope drift

float accelz = 0;
float angle;
float angleY_one;
float angle_speed;

float Pdot[4] = { 0, 0, 0, 0};
float P[2][2] = {{ 1, 0 }, { 0, 1 }};
float  PCt_0, PCt_1, E;
//////////////////////Kalman_Filter/////////////////////////

//////////////////////PD parameters///////////////////////////////
double kp = 34, ki = 0, kd = 0.62;                   //Angle loop parameter
double setp0 = 0; //Angle balance point
int PD_pwm;  //angle output
float pwm1=0,pwm2=0;

//void anglePWM();

void setup() 
{
  //set the control motor’s pin to OUTPUT
  pinMode(right_R1,OUTPUT);       
  pinMode(right_R2,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(PWM_L,OUTPUT);

  //Initial state value
  digitalWrite(right_R1,1);
  digitalWrite(right_R2,0);
  digitalWrite(left_L1,0);
  digitalWrite(left_L2,1);
  analogWrite(PWM_R,0);
  analogWrite(PWM_L,0);

  // Join I2C bus
  Wire.begin();                            //Join the I2C bus sequence
  Serial.begin(9600);                       //open serial monitor, set the baud rate to 9600
  delay(1500);
  mpu6050.initialize();                       //initialize MPU6050
  delay(2);

  //5ms  use timer2 to set the timer interrupt (Note: using timer2 will affect the PWM output of pin3 pin11.)
  MsTimer2::set(5, DSzhongduan);    //5ms execute the function DSzhongduan once
  MsTimer2::start();    // start the interrupt
}

void loop() 
{
  Serial.print("angle = ");
  Serial.println(angle);
  Serial.print("Angle = ");
  Serial.println(Angle);

  /*Serial.print("Gyro_x = ");
  Serial.println(Gyro_x);
  Serial.print("K_Gyro_x = ");
  Serial.println(angle_speed);*/
  
  //Serial.println(PD_pwm);
  //Serial.println(pwm1);
  //Serial.println(pwm2);
}

/////////////////////////////////interrupt////////////////////////////
void DSzhongduan()
{
  sei();  //Allow overall interrupt
  mpu6050.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);     //IIC to get MPU6050 six-axis data ax ay az gx gy gz
  angle_calculate(ax, ay, az, gx, gy, gz, dt, Q_angle, Q_gyro, R_angle, C_0, K1);      //get angle and Kalman_Filter
  PD();         // angle loop of PD control
  anglePWM();
}

/////////////////////////////angle calculation///////////////////////
void angle_calculate(int16_t ax,int16_t ay,int16_t az,int16_t gx,int16_t gy,int16_t gz,float dt,float Q_angle,float Q_gyro,float R_angle,float C_0,float K1)
{
  Angle = -atan2(ay , az) * (180/ PI);           //Radial rotation angle calculation formula; negative sign is direction processing
  Gyro_x = -gx / 131;              //The X-axis angular velocity calculated by the gyroscope; the negative sign is the direction processing
  Kalman_Filter(Angle, Gyro_x);            //  Kalman Filter
  //Rotation Angle Z axis parameter
  Gyro_z = -gz / 131;                      //Z-axis angular velocity
  //accelz = az / 16.4;

  float angleAx = -atan2(ax, az) * (180 / PI); //Calculate the angle with the x-axis
  Gyro_y = -gy / 131.00; //Y-axis angular velocity
  Yiorderfilter(angleAx, Gyro_y); //first-order filter
}

///////////////////////////////KalmanFilter/////////////////////
void Kalman_Filter(double angle_m, double gyro_m)
{
  angle += (gyro_m - q_bias) * dt;          //Prior estimate
  angle_err = angle_m - angle;
  
  Pdot[0] = Q_angle - P[0][1] - P[1][0];    //Differential of azimuth error covariance
  Pdot[1] = - P[1][1];
  Pdot[2] = - P[1][1];
  Pdot[3] = Q_gyro;
  
  P[0][0] += Pdot[0] * dt;    //A priori estimation error covariance differential integral
  P[0][1] += Pdot[1] * dt;
  P[1][0] += Pdot[2] * dt;
  P[1][1] += Pdot[3] * dt;
  
  //Intermediate variable of matrix multiplication
  PCt_0 = C_0 * P[0][0];
  PCt_1 = C_0 * P[1][0];
  //Denominator 
  E = R_angle + C_0 * PCt_0;
  //gain value
  K_0 = PCt_0 / E;
  K_1 = PCt_1 / E;
  
  t_0 = PCt_0;  //Intermediate variable of matrix multiplication
  t_1 = C_0 * P[0][1];
  
  P[0][0] -= K_0 * t_0;    //Posterior estimation error covariance
  P[0][1] -= K_0 * t_1;
  P[1][0] -= K_1 * t_0;
  P[1][1] -= K_1 * t_1;
  
  q_bias += K_1 * angle_err;    //Posterior estimate
  angle_speed = gyro_m - q_bias;   //The differential of the output value gives the optimal angular velocity
  angle += K_0 * angle_err; ////Posterior estimation to get the optimal angle
}

///////////////first-order Filter///////////////
void Yiorderfilter(float angle_m, float gyro_m)
{
  angleY_one = K1 * angle_m + (1 - K1) * (angleY_one + gyro_m * dt);
}

//////////////////angle PD////////////////////
void PD()
{
  PD_pwm = kp * (angle + angle0) + kd * angle_speed; //PD angle loop control
}

/////////////PWM end value////////////////////
void anglePWM()
{
  pwm2=-PD_pwm;            //The final value assigned to the motor PWM
  pwm1=-PD_pwm;
  
  if(pwm1>255)             //limit PWM value not greater than 255
  {
    pwm1=255;
  }
  if(pwm1<-255) 
  {
    pwm1=-255;
  }
  if(pwm2>255)
  {
    pwm2=255;
  }
  if(pwm2<-255)
  {
    pwm2=-255;
  }

  if(angle>80 || angle<-80)      //When the self-balancing trolley’s tilt angle is greater than 45 degrees, the motor will stop.
  {
    pwm1=pwm2=0;
  }

  if(pwm2>=0)         //determine the motor’s steering and speed by the positive and negative of PWM 
  {
    digitalWrite(left_L1,LOW);
    digitalWrite(left_L2,HIGH);
    analogWrite(PWM_L,pwm2);
  }
  else
  {
    digitalWrite(left_L1,HIGH);
    digitalWrite(left_L2,LOW);
    analogWrite(PWM_L,-pwm2);
  }

  if(pwm1>=0)
  {
    digitalWrite(right_R1,LOW);
    digitalWrite(right_R2,HIGH);
    analogWrite(PWM_R,pwm1);
  }
  else
  {
    digitalWrite(right_R1,HIGH);
    digitalWrite(right_R2,LOW);
    analogWrite(PWM_R,-pwm1);
  }
}
```

**Test Result**

Installed well the balance car, upload the source code and power on; turn the power switch ON.

The balance car will stand upright on the desktop.

Then open the Arduino IDE, set the baud rate to 9600, the serial monitor will pop up the inclined value before filtering and after filtering.

![](media/f0773cc27ba2cb214458b74c9c06f7a4.png)



## Project 11: Speed Loop Adjustment

![](media/d36824f1d6537907e3426bddcc8eca98.jpeg)

**Description:**

We have introduced before that can adjust the angle to balance the car on the almost horizontal ground by controlling the PD. 

However, if subjected to external forces or on a slope, the car can't keep balance because there is an error in speed. So you need to adjust the speed of the car for balancing. 

Therefore, a speed measuring module is required.

**The motor we used comes with a Hall encoder for speed measurement.**

Based on the previous lesson, add a PI (proportional and integral) control to adjust the speed. In this way, it is possible to control the car to be balanced even if it is on a slope.

The speed loop here is positive feedback, which means that if the car is going backwards, then the car will move forward at a faster speed. 

To be specific, if gently push the car with hand, the wheel of the car accelerates in the direction of pushing, that is, the direction in which the car is tilted, so that the tilt angle of the car is reversed in the opposite direction, that is, contrary to the direction of pushing;  the car will accelerate in the direction of tilting, and the speed is accelerated.

The PI adjustment of speed just offsets the previously generated dip angle, and returns to near the initial equilibrium point without falling.

**Principle and function of PI regulation:**

**PI_pwm = ki_speed \* (setp0 - positions) + kp_speed \* (setp0 - speeds_filter);** // speed loop control

Adjust the speed with the proportional parameter **(** **kp_speed )**, so that the car can quickly approach the required speed;

Adjust the accumulated value of the speed error with the integral parameter **(ki_speed)** to eliminate the static error.

![](media/06ad11db8db6c0c75411d8f6ccd38a4a.jpeg)

**For example:**

Supposed that there is a water vat, ensure that the water level in the vat is maintained at a height of 1 meter forever.

Suppose the initial water level is 0.2 meter, then there is an error between the current water level and the target water level, and the error is 0.8m.

At this time, you want to control the water level by adding water.

If simply use the Proportional control algorithm, the amount of water added **(u)** is proportional to the error. That is, **u=kp\*error**

Supposed **kp=0.5**, **t=1** (add water in the first time), so **u=0.5\*0.8=0.4** , should add the water quantity of 0.4m; now the current water level should be **0.2m+0.4m=0.6m**

Then **t=2** (add water in the second time), this time water level 0.6m, error 0.4m, so should add the water quantity **u=0.5\*0.4=0.2 ;** now the current water level should be **0.6m+0.2m=0.8m**

Followed by this calculation. The water level will reach 1m.

But there are some shortcomings in such single proportional control, one of which is – **steady state error!**

Like the above example, depending on the value of **kp**, the system will eventually reach 1 meter without steady state error.

However, considering another situation, suppose that there is water leakage in the process of adding water to the water tank. It is assumed that the water of 0.1 m height will be missed every time the water is added.

Supposed **kp=0.5**, after several times of adding water, the water level in the water tank will reach 0.8m, the water level will not change again! Because the water level is 0.8m, the **error =1-0.8=0.2m**.

Therefore, the amount of water added to the water tank is **u=0.5\*0.2=0.1m**.

At the same time, 0.1m of water will flow out from the water tank every time. The added water offsets the leaked water, so the water level will not change!

In other words, the target water level is 1m, but finally the water system reaches 0.8m and not changes. The system has reached stability. The resulting error is the steady-state error.

Therefore, separate proportional control does not meet the requirements in many cases. So we need integral control algorithm.

From the above example, you can find that if only use proportional control, may exist the Transient error, so the water level will be only 0.8m.

In control, we introduce a component that is proportional to the integral of the error. 

**Therefore, the proportional + integral control algorithm is:**

**u=kp\*error+ ki∗∫error**

Here we still use the example mentioned above. 

The error of the first time is 0.8, and error of the second time is 0.4. At this point, the integral of the error (in the case of discrete, the integral is actually accumulating)

![image-20230426164915487](media/image-20230426164915487.png)

The amount of control at this time, in addition to a part of proportion, another part is a coefficient **ki** multiplied by this integral term.

Since this integral term will accumulate the previous errors, the steady-state error can be well eliminated.

(assuming that in the case of only proportional terms, the system is stuck in the steady-state error, i.e. 0.8 in the above example. Due to the addition of the integral term, input will increase so that the water level of the tank can be greater than 0.8 and gradually reach the target's 1.0.) 

This is the function of integral term.

**Source Code:**

```c
#include <MsTimer2.h>        //internal timer 2
#include <PinChangeInt.h>    //This library file can make all pins on the UNO board as external interrupts.
#include <MPU6050.h>      //MPU6050 library
#include <Wire.h>        //IIC library

MPU6050 mpu6050;     //Instantiate an MPU6050 object; name mpu6050
int16_t ax, ay, az, gx, gy, gz;     // Define three-axis acceleration, three-axis gyroscope variables

//TB6612 pins
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

///////////////////////angle parameters//////////////////////////////
float angle_X; //Calculate the tilt angle variable about the X axis from the acceleration
float angle_Y; //Calculate the tilt angle variable about the Y axis from the acceleration
float angle0 = 1; //Actual measured angle (ideally 0 degrees)
float Gyro_x,Gyro_y,Gyro_z;  //Angular angular velocity by gyroscope calculation
///////////////////////angle parameters//////////////////////////////

///////////////////////Kalman_Filter////////////////////////////
float Q_angle = 0.001;  //Covariance of gyroscope noise
float Q_gyro = 0.003;    //Covariance of gyroscope drift noise
float R_angle = 0.5;    //Covariance of accelerometer
char C_0 = 1;
float dt = 0.005; // The value of dt is the filter sampling time. 
float K1 = 0.05; //a function containing the Kalman gain is used to calculate the deviation of the optimal estimate 
float K_0,K_1,t_0,t_1;
float angle_err;
float q_bias;    //Gyro drift

float accelz = 0;
float angle;
float angleY_one;
float angle_speed;

float Pdot[4] = { 0, 0, 0, 0};
float P[2][2] = {{ 1, 0 }, { 0, 1 }};
float  PCt_0, PCt_1, E;
//////////////////////Kalman_Filter/////////////////////////

//////////////////////PID parameters///////////////////////////////
double kp = 34, ki = 0, kd = 0.62;                   //angle loop parameters
double kp_speed = 3.6, ki_speed = 0.080, kd_speed = 0;   // speed loop parameters
double setp0 = 0; //angle balance point
int PD_pwm;  //angle output
float pwm1=0,pwm2=0;

//////////////////Interrupt speed measurement/////////////////////////////
#define PinA_left 5  //external interrupts
#define PinA_right 4   //external interrupts
volatile long count_right = 0;//Used to calculate the pulse value calculated by the Hall encoder (the volatile long type is to ensure the value is valid)
volatile long count_left = 0;
int speedcc = 0;
//////////////////////pulse calculation/////////////////////////
int lz = 0;
int rz = 0;
int rpluse = 0;
int lpluse = 0;
int pulseright,pulseleft;
////////////////////////////////PI variable parameters//////////////////////////
float speeds_filterold=0;
float positions=0;
int flag1;
double PI_pwm;
int cc;
int speedout;
float speeds_filter;

void setup() 
{
  // set the pins of motor to OUTPUT
  pinMode(right_R1,OUTPUT);       
  pinMode(right_R2,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(PWM_L,OUTPUT);

  //assign initial state value
  digitalWrite(right_R1,1);
  digitalWrite(right_R2,0);
  digitalWrite(left_L1,0);
  digitalWrite(left_L2,1);
  analogWrite(PWM_R,0);
  analogWrite(PWM_L,0);

  pinMode(PinA_left, INPUT);  //speed code wheel input
  pinMode(PinA_right, INPUT);

  // join I2C bus
  Wire.begin();                            //join I2C bus sequence
  Serial.begin(9600);                       //open the serial monitor to set the baud rate to 9600
  delay(1500);
  mpu6050.initialize();                       //initialize MPU6050
  delay(2);

  //5ms; use timer2 to set timer interruption (note：using timer2 will affect the PWM output of pin3 pin11)
  MsTimer2::set(5, DSzhongduan);    //5ms ; execute the function DSzhongduan once
  MsTimer2::start();    //start interrupt
}

void loop() 
{
  Serial.println(angle);
  delay(100);
  //Serial.println(PD_pwm);
  //Serial.println(pwm1);
  //Serial.println(pwm2);
  //Serial.print("pulseright = ");
  //Serial.println(pulseright);
  //Serial.print("pulseleft = ");
  //Serial.println(pulseleft);
  //Serial.println(PI_pwm);
  //Serial.println(speeds_filter);
  //Serial.println (positions);
  
  //External interrupt for calculating wheel speed 
  attachPinChangeInterrupt(PinA_left, Code_left, CHANGE);          //PinA_left Level change triggers external interrupt; execute subfunction Code_left
  attachPinChangeInterrupt(PinA_right, Code_right, CHANGE);       //PinA_right Level change triggers external interrupt; execute subfunction Code_right
}

/////////////////////Hall calculation/////////////////////////
//left speed code wheel count
void Code_left() 
{
  count_left ++;
} 
//Right speed code wheel count
void Code_right() 
{
  count_right ++;
} 
////////////////////pulse calculation///////////////////////
void countpluse()
{
  lz = count_left;     //Assign the value counted by the code wheel to lz
  rz = count_right;

  count_left = 0;     //Clear the code counter count
  count_right = 0;

  lpluse = lz;
  rpluse = rz;

  if ((pwm1 < 0) && (pwm2 < 0))                     //judge the moving direction; if backwards（PWM, namely motor voltage is negative）, pulse number is a negative number
  {
    rpluse = -rpluse;
    lpluse = -lpluse;
  }
  else if ((pwm1 > 0) && (pwm2 > 0))                 // if backwards（PWM, namely motor voltage is positive）, pulse number is a positive number
  {
    rpluse = rpluse;
    lpluse = lpluse;
  }
  else if ((pwm1 < 0) && (pwm2 > 0))                 //Judge turning direction of the car;  turn left; Right pulse number is a positive number; Left pulse number is a negative number.
  {
    rpluse = rpluse;
    lpluse = -lpluse;
  }
  else if ((pwm1 > 0) && (pwm2 < 0))               //Judge turning direction of the car;  turn right; Right pulse number is a negative number; Left pulse number is a positive number.
  {
    rpluse = -rpluse;
    lpluse = lpluse;
  }

  //enter interrupts per 5ms; pulse number superposes
  pulseright += rpluse;
  pulseleft += lpluse;
}

/////////////////////////////////interrupts////////////////////////////
void DSzhongduan()
{
  sei();  //Allow global interrupts
  countpluse();        //Pulse superposition subfunction
  mpu6050.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);     //IIC to get MPU6050 six-axis data  ax ay az gx gy gz
  angle_calculate(ax, ay, az, gx, gy, gz, dt, Q_angle, Q_gyro, R_angle, C_0, K1);      //get angle and Kalman filtering
  PD();         //angle loop PD control
  anglePWM();

  cc++;
  if(cc>=8)     //5*8=40，40ms entering once speed PI algorithm  
  {
    speedpiout();   
    cc=0;  //Clear
  }
}
///////////////////////////////////////////////////////////

/////////////////////////////angle calculation///////////////////////
void angle_calculate(int16_t ax,int16_t ay,int16_t az,int16_t gx,int16_t gy,int16_t gz,float dt,float Q_angle,float Q_gyro,float R_angle,float C_0,float K1)
{
  float Angle = -atan2(ay , az) * (180/ PI);           //Radial rotation angle calculation formula; negative sign is direction processing
  Gyro_x = -gx / 131;              //The X-axis angular velocity calculated by the gyroscope; the negative sign is the direction processing
  Kalman_Filter(Angle, Gyro_x);            //Kalman Filtering
  //Rotation angle Z-axis parameter
  Gyro_z = -gz / 131;                      //Z-axis angular velocity
  //accelz = az / 16.4;

  float angleAx = -atan2(ax, az) * (180 / PI); //Calculate the angle with the x-axis
  Gyro_y = -gy / 131.00; //Y-axis angular velocity
  Yiorderfilter(angleAx, Gyro_y); //first-order filtering
}
////////////////////////////////////////////////////////////////

///////////////////////////////KalmanFilter/////////////////////
void Kalman_Filter(double angle_m, double gyro_m)
{
  angle += (gyro_m - q_bias) * dt;          //Prior estimate
  angle_err = angle_m - angle;
  
  Pdot[0] = Q_angle - P[0][1] - P[1][0];    //Differential of azimuth error covariance
  Pdot[1] = - P[1][1];
  Pdot[2] = - P[1][1];
  Pdot[3] = Q_gyro;
  
  P[0][0] += Pdot[0] * dt;    //A priori estimation error covariance differential integral
  P[0][1] += Pdot[1] * dt;
  P[1][0] += Pdot[2] * dt;
  P[1][1] += Pdot[3] * dt;
  
  //Intermediate variable of matrix multiplication 
  PCt_0 = C_0 * P[0][0];
  PCt_1 = C_0 * P[1][0];
  //Denominator
  E = R_angle + C_0 * PCt_0;
  //gain value
  K_0 = PCt_0 / E;
  K_1 = PCt_1 / E;
  
  t_0 = PCt_0;  //Intermediate variable of matrix multiplication
  t_1 = C_0 * P[0][1];
  
  P[0][0] -= K_0 * t_0;    //Posterior estimation error covariance
  P[0][1] -= K_0 * t_1;
  P[1][0] -= K_1 * t_0;
  P[1][1] -= K_1 * t_1;
  
  q_bias += K_1 * angle_err;    //Posterior estimate 
  angle_speed = gyro_m - q_bias;   //The differential of the output value gives the optimal angular velocity
  angle += K_0 * angle_err; ////Posterior estimation to get the optimal angle
}

/////////////////////first-order filtering/////////////////
void Yiorderfilter(float angle_m, float gyro_m)
{
  angleY_one = K1 * angle_m + (1 - K1) * (angleY_one + gyro_m * dt);
}

//////////////////angle PD////////////////////
void PD()
{
  PD_pwm = kp * (angle + angle0) + kd * angle_speed; //PD angle loop control
}

//////////////////speed PI////////////////////
void speedpiout()
{
  float speeds = (pulseleft + pulseright) * 1.0;      //Vehicle speed  pulse value
  pulseright = pulseleft = 0;      //Clear
  speeds_filterold *= 0.7;         //first-order complementary filtering
  speeds_filter = speeds_filterold + speeds * 0.3;
  speeds_filterold = speeds_filter;
  positions += speeds_filter;
  positions = constrain(positions, -3550,3550);    //Anti-integral saturation
  PI_pwm = ki_speed * (setp0 - positions) + kp_speed * (setp0 - speeds_filter);      //speed loop control PI
}
//////////////////speed PI////////////////////


////////////////////////////PWM end value/////////////////////////////
void anglePWM()
{
  pwm2=-PD_pwm - PI_pwm ;           //assign the final value of PWM to motor 
  pwm1=-PD_pwm - PI_pwm ;
  
  if(pwm1>255)             //limit PWM value not greater than 255
  {
    pwm1=255;
  }
  if(pwm1<-255) 
  {
    pwm1=-255;
  }
  if(pwm2>255)
  {
    pwm2=255;
  }
  if(pwm2<-255)
  {
    pwm2=-255;
  }

  if(angle>80 || angle<-80) // the inclined angle of balance car is greater than 45°, motor will stop. 
  {
    pwm1=pwm2=0;
  }

 if(pwm2>=0)// determine the motor’s steering and speed according to the positive and negative of PWM
  {
    digitalWrite(left_L1,LOW);
    digitalWrite(left_L2,HIGH);
    analogWrite(PWM_L,pwm2);
  }
  else
  {
    digitalWrite(left_L1,HIGH);
    digitalWrite(left_L2,LOW);
    analogWrite(PWM_L,-pwm2);
  }

  if(pwm1>=0)
  {
    digitalWrite(right_R1,LOW);
    digitalWrite(right_R2,HIGH);
    analogWrite(PWM_R,pwm1);
  }
  else
  {
    digitalWrite(right_R1,HIGH);
    digitalWrite(right_R2,LOW);
    analogWrite(PWM_R,-pwm1);
  }
}
```

**Test Result**

Installed well the balance car, upload the source code and power on; turn the power switch ON.

The balance car will stand upright on the desktop.

Then open the Arduino IDE, set the baud rate to 9600, the serial monitor will pop up the inclined value of balance car.

![](media/de2cefbcbd5c24b84c9472fc5e03cf8b.png)

Remove the USB cable and balance the car upright on the ground. 

If you push it gently by hand, the car will advance in the direction you push, but the tilt angle of the car is opposite to the direction of the push, so the car will return to the balance point without falling. 

## Project 12: Steering Loop Control

**Description:**

The steering of the car also needs to be adjusted by the PD.

The balance robot is driven by the left and right motor speed difference to eliminate the deviation from the center of the road. 

By adjusting the direction of the balancing robot and adding the balancing robot to the forward motion, the distance difference between the balancing robot and the center line can be gradually eliminated. 

This process is a proportional P process, so the differential control of balance robot generally only needs simple proportional control to complete the direction control.

However, since the robot car itself is equipped with a relatively heavy object such as a battery, it has a large moment of inertia. It may occurs steering overshoot phenomenon during the adjustment process. If it is not suppressed, the balance robot will oversteer and fall down.

According to the experience of angle and speed control mentioned above, in order to eliminate the overshoot in the direction control of balance robot, it is necessary to increase the angle differential D control.

![](media/a690085f6bf92344a8fd907f7d755461.png)



## Project 13: Bluetooth Control

**Description:**

In the above projects, you have learned how to balance the robot upright; how to use the Bluetooth APP to control the balancing robot.

In this project, let’s move on to combine these two functions. To begin with, control the balance robot stand upright; then make the robot move in different directions using Android Bluetooth control. 

![](media/f040a9f803dbb510ff82ce1fb9454b4e.png)

However, due to the errors caused by the installation and the mpu6050, there may be a phenomenon that go fast and easily fall down or slow to turn back or can’t move. The solution please refer to the project 12 and the second section mentioned below.

**Notice:**

Thew balance shield comes with a slide switch for Bluetooth communication. When upload the code for testing, must turn the switch OFF; or else, uploading fails.

When connect to Bluetooth module, should turn the switch ON.

**Source Code:**

**Note:**

Before test the source code, do remember to add the corresponding library.

You can refer to the method in the link below:

<https://wiki.keyestudio.com/How_to_Install_Arduino_Library>

```c
#include <MsTimer2.h>        //internal timer 2
#include <PinChangeInt.h>    //this library can make all pins of arduino UNO as external interrupt
#include <MPU6050.h>      //MPU6050 library 
#include <Wire.h>        //IIC communication library 

MPU6050 mpu6050;     //Instantiate an MPU6050 object; name mpu6050
int16_t ax, ay, az, gx, gy, gz;     //Define three-axis acceleration, three-axis gyroscope variables

//TB6612 pins
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

///////////////////////angle parameters//////////////////////////////
float angle_X; //calculate the inclined angle variable of X-axis by accelerometer  
float angle_Y; //calculate the inclined angle variable of Y-axis by accelerometer
float angle0 = 1; //Actual measured angle (ideally 0 degrees) 
float Gyro_x,Gyro_y,Gyro_z;  //Angular angular velocity for gyroscope calculation 
///////////////////////angle parameters//////////////////////////////

///////////////////////Kalman_Filter////////////////////////////
float Q_angle = 0.001;  //Covariance of gyroscope noise
float Q_gyro = 0.003;    //Covariance of gyroscope drift noise
float R_angle = 0.5;    //Covariance of accelerometer
char C_0 = 1;
float dt = 0.005; //The value of dt is the filter sampling time
float K1 = 0.05; //  a function containing the Kalman gain; used to calculate the deviation of the optimal estimate
float K_0,K_1,t_0,t_1;
float angle_err;
float q_bias;    //gyroscope drift

float accelz = 0;
float angle;
float angleY_one;
float angle_speed;

float Pdot[4] = { 0, 0, 0, 0};
float P[2][2] = {{ 1, 0 }, { 0, 1 }};
float  PCt_0, PCt_1, E;
//////////////////////Kalman_Filter/////////////////////////

//////////////////////PID parameters///////////////////////////////
double kp = 34, ki = 0, kd = 0.62;                   //angle loop parameters
double kp_speed = 3.6, ki_speed = 0.080, kd_speed = 0;   // speed loop parameters
double kp_turn = 24, ki_turn = 0, kd_turn = 0.08;       // steering loop parameters
double setp0 = 0; //Angle balance point 
int PD_pwm;  //angle output
float pwm1=0,pwm2=0;

//////////////////Interrupt speed count/////////////////////////////
#define PinA_left 5  //external interrupt
#define PinA_right 4   //external interrupt 
volatile long count_right = 0;//Used to calculate the pulse value calculated by the Hall encoder (the volatile long type is to ensure the value is valid)
volatile long count_left = 0;
int speedcc = 0;
//////////////////////pulse count/////////////////////////
int lz = 0;
int rz = 0;
int rpluse = 0;
int lpluse = 0;
int pulseright,pulseleft;
////////////////////////////////PI variable parameter//////////////////////////
float speeds_filterold=0;
float positions=0;
int flag1;
double PI_pwm;
int cc;
int speedout;
float speeds_filter;

//////////////////////////////steering PD///////////////////
int turnmax,turnmin,turnout; 
float Turn_pwm = 0;
int zz=0;
int turncc=0;

//Bluetooth//
int front = 0;//go front variable
int back = 0;//go back variable
int left = 0;//turn left
int right = 0;//turn right
char val;

void setup() 
{
  //set the motor control pins to OUTPUT
  pinMode(right_R1,OUTPUT);       
  pinMode(right_R2,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(PWM_L,OUTPUT);

  //assign initial state value
  digitalWrite(right_R1,1);
  digitalWrite(right_R2,0);
  digitalWrite(left_L1,0);
  digitalWrite(left_L2,1);
  analogWrite(PWM_R,0);
  analogWrite(PWM_L,0);

  pinMode(PinA_left, INPUT);  //Speed encoder input
  pinMode(PinA_right, INPUT);

  // join I2C bus
  Wire.begin();                            //join I2C bus sequence 
  Serial.begin(9600);                       //open the serial monitor and set the baud rate to 9600
  delay(1500);
  mpu6050.initialize();                       //initialize MPU6050
  delay(2);

  //5ms; use timer2 to set timer interruption (note：using timer2 will affect the PWM output of pin3 pin11)
  MsTimer2::set(5, DSzhongduan);    //5ms ; execute the function DSzhongduan once
  MsTimer2::start();    //start interrupt
}

void loop() 
{
  Serial.print(angle_speed);
  Serial.print("     ");
  Serial.println(Gyro_x);
  
  //Serial.println(angle);
  //delay(100);
  //Serial.println(PD_pwm);
  //Serial.println(pwm1);
  //Serial.println(pwm2);
  //Serial.print("pulseright = ");
  //Serial.println(pulseright);
  //Serial.print("pulseleft = ");
  //Serial.println(pulseleft);
  //Serial.println(PI_pwm);
  //Serial.println(speeds_filter);
  //Serial.println (positions);
  //Serial.println(Turn_pwm);
  //Serial.println(Gyro_z);
  //Serial.println(Turn_pwm);
  

  if(Serial.available())
  {
    val = Serial.read();      //assign the value read from serial port to val
    //Serial.println(val);
    switch(val)             //switch statement
    {
      case 'F': front=250; break;       //if val equals to F，front=250，balance robot goes front.
      case 'B': back=-250; break;       //go back
      case 'L': left=1; break;    //turn left
      case 'R': right=1; break;                         // turn right
      case 'S': front=0,back=0,left=0,right=0;break;    //stop
      case 'D': Serial.print(angle);break;    //when receiving ‘D’，send value of angle to APP
    }
  }
  
  //external interrupt; used to calculate the wheel speed
  attachPinChangeInterrupt(PinA_left, Code_left, CHANGE);          //PinA_left  Level change triggers external interrupt;  execute subfunction Code_left
  attachPinChangeInterrupt(PinA_right, Code_right, CHANGE);       //PinA_right Level change triggers external interrupt;  execute subfunction Code_right
}

/////////////////////Hall count/////////////////////////
//left speed encoder count
void Code_left() 
{
  count_left ++;
} 
//right speed encoder count
void Code_right() 
{
  count_right ++;
} 
////////////////////pulse count///////////////////////
void countpluse()
{
  lz = count_left;     //assign the value counted by encoder to lz
  rz = count_right;

  count_left = 0;     //clear the count quantity
  count_right = 0;

  lpluse = lz;
  rpluse = rz;

  if ((pwm1 < 0) && (pwm2 < 0))                     //judge the moving direction of balance robot; if go back (PWM the motor voltage is negative), the number of pulses is negative.
  {
    rpluse = -rpluse;
    lpluse = -lpluse;
  }
  else if ((pwm1 > 0) && (pwm2 > 0))                 // if go back (PWM the motor voltage is positive) , the number of pulses is positive.
  {
    rpluse = rpluse;
    lpluse = lpluse;
  }
  else if ((pwm1 < 0) && (pwm2 > 0))                 //judge the moving direction of balance robot; if turn left, right pulse is positive but left pulse is negative.
  {
    rpluse = rpluse;
    lpluse = -lpluse;
  }
  else if ((pwm1 > 0) && (pwm2 < 0))               //judge the moving direction of balance robot; if turn right , right pulse is negative but left pulse is positive.
  {
    rpluse = -rpluse;
    lpluse = lpluse;
  }

  //entering interrupt per 5ms，pulse will plus
  pulseright += rpluse;
  pulseleft += lpluse;
}

/////////////////////////////////interrupt ////////////////////////////
void DSzhongduan()
{
  sei();  //allow overall interrupt
  countpluse();        //pulse count subfunction
  mpu6050.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);     //IIC to get MPU6050 six-axis data ax ay az gx gy gz
  angle_calculate(ax, ay, az, gx, gy, gz, dt, Q_angle, Q_gyro, R_angle, C_0, K1);      //get the angle and Kalman filtering
  PD();         //PD control of angle loop 
  anglePWM();

  cc++;
  if(cc>=8)     //5*8=40，40ms entering PI count of speed once
  {
    speedpiout();   
    cc=0;  // Clear
  }
  turncc++;         
  if(turncc>4)       //20ms entering PI count of steering once
  {
    turnspin();
    turncc=0;     //Clear
  }
}
///////////////////////////////////////////////////////////

/////////////////////////////tilt angle calculation///////////////////////
void angle_calculate(int16_t ax,int16_t ay,int16_t az,int16_t gx,int16_t gy,int16_t gz,float dt,float Q_angle,float Q_gyro,float R_angle,float C_0,float K1)
{
  float Angle = -atan2(ay , az) * (180/ PI);           //Radial rotation angle calculation formula; the negative sign is direction processing.
  Gyro_x = -gx / 131;              //The X-axis angular velocity calculated by the gyroscope ; the negative sign is the direction processing.
  Kalman_Filter(Angle, Gyro_x);            // Kalman Filter
  // Z-axis angular velocity
  Gyro_z = -gz / 131;                      //speed of Z-axis 
  //accelz = az / 16.4;

  float angleAx = -atan2(ax, az) * (180 / PI); //calculate the included angle of X-axis  
  Gyro_y = -gy / 131.00; //angle speed of Y-axis 
  Yiorderfilter(angleAx, Gyro_y); //first-order filtering
}
////////////////////////////////////////////////////////////////

///////////////////////////////KalmanFilter/////////////////////
void Kalman_Filter(double angle_m, double gyro_m)
{
  angle += (gyro_m - q_bias) * dt;          //prior estimate
  angle_err = angle_m - angle;
  
  Pdot[0] = Q_angle - P[0][1] - P[1][0];    //The differential of the covariance of the prior estimate error 
  Pdot[1] = - P[1][1];
  Pdot[2] = - P[1][1];
  Pdot[3] = Q_gyro;
  
  P[0][0] += Pdot[0] * dt;    //The integral of the covariance differential of the prior estimate error
  P[0][1] += Pdot[1] * dt;
  P[1][0] += Pdot[2] * dt;
  P[1][1] += Pdot[3] * dt;
  
  //Intermediate variables in matrix multiplication
  PCt_0 = C_0 * P[0][0];
  PCt_1 = C_0 * P[1][0];
  //denominator
  E = R_angle + C_0 * PCt_0;
  //gain value
  K_0 = PCt_0 / E;
  K_1 = PCt_1 / E;
  
  t_0 = PCt_0;  //Intermediate variables in matrix multiplication 
  t_1 = C_0 * P[0][1];
  
  P[0][0] -= K_0 * t_0;    //the covariance of the prior estimate error 
  P[0][1] -= K_0 * t_1;
  P[1][0] -= K_1 * t_0;
  P[1][1] -= K_1 * t_1;
  
  q_bias += K_1 * angle_err;    //posterior estimate
  angle_speed = gyro_m - q_bias;   //The differential of the output value; get the optimal angular velocity
  angle += K_0 * angle_err; ////posterior estimate; get the optimal angular velocity
}

/////////////////////first-order filtering/////////////////
void Yiorderfilter(float angle_m, float gyro_m)
{
  angleY_one = K1 * angle_m + (1 - K1) * (angleY_one + gyro_m * dt);
}

//////////////////angle PD////////////////////
void PD()
{
  PD_pwm = kp * (angle + angle0) + kd * angle_speed; //PD angle loop control 
}

//////////////////speed PI////////////////////
void speedpiout()
{
  float speeds = (pulseleft + pulseright) * 1.0;      //pulse value of speed  
  pulseright = pulseleft = 0;      //Clear 
  speeds_filterold *= 0.7;         //first-order complementary filtering
  speeds_filter = speeds_filterold + speeds * 0.3;
  speeds_filterold = speeds_filter;
  positions += speeds_filter;
  positions += front;             //Forward control fusion
  positions += back;              //backward control fusion
  positions = constrain(positions, -3550,3550);    //Anti-integral saturation
  PI_pwm = ki_speed * (setp0 - positions) + kp_speed * (setp0 - speeds_filter);      //speed loop controlling PI
}
//////////////////speed PI////////////////////

///////////////////////////steering/////////////////////////////////
void turnspin()
{
  int flag = 0;      //
  float turnspeed = 0;
  float rotationratio = 0;
  
  if (left == 1 || right == 1)
  {
    if (flag == 0)                             //judge the speed before turning; increase the car’s flexibility.
    {
      turnspeed = ( pulseright + pulseleft);                      //current speed of car; pulse expression
      flag=1;
    }
    if (turnspeed < 0)                                 //Absolute value of the car's current speed
    {
      turnspeed = -turnspeed;
    }
    if(left==1||right==1)         //if press left key or right key
    {
     turnmax=3;          //maximum value of turning
     turnmin=-3;         // minimum value of turning
    }
    rotationratio = 5 / turnspeed;          //set the value by speed
    if (rotationratio < 0.5)
    {
      rotationratio = 0.5;
    }
     
    if (rotationratio > 5)
    {
      rotationratio = 5;
    }
  }
  else
  {
    rotationratio = 0.5;
    flag = 0;
    turnspeed = 0;
  }
  if (left ==1)//plus by direction parameter
  {
    turnout += rotationratio;
  }
  else if (right == 1 )//plus by direction parameter
  {
    turnout -= rotationratio;
  }
  else turnout = 0;
  if (turnout > turnmax)   turnout = turnmax;//the max value setting of amplitude
  if (turnout < turnmin)   turnout = turnmin;//the min value setting of amplitude 

  Turn_pwm = -turnout * kp_turn - Gyro_z * kd_turn;//The rotation PD algorithm controls the fusion speed and Z axis rotation positioning
}
///////////////////////////turning/////////////////////////////////

////////////////////////////PWM end value/////////////////////////////
void anglePWM()
{
  pwm2=-PD_pwm - PI_pwm + Turn_pwm;           //assign the end value of PWM to motor
  pwm1=-PD_pwm - PI_pwm - Turn_pwm;
  
  if(pwm1>255)             //limit the PWM value not more than 255
  {
    pwm1=255;
  }
  if(pwm1<-255) 
  {
    pwm1=-255;
  }
  if(pwm2>255)
  {
    pwm2=255;
  }
  if(pwm2<-255)
  {
    pwm2=-255;
  }

  if(angle>80 || angle<-80)      //if tilt angle is greater than 45° , motor will stop.
  {
    pwm1=pwm2=0;
  }

 if(pwm2>=0)         //motor’s turning and speed are determined by the positive or negative of PWM
  {
    digitalWrite(left_L1,LOW);
    digitalWrite(left_L2,HIGH);
    analogWrite(PWM_L,pwm2);
  }
  else
  {
    digitalWrite(left_L1,HIGH);
    digitalWrite(left_L2,LOW);
    analogWrite(PWM_L,-pwm2);
  }

  if(pwm1>=0)
  {
    digitalWrite(right_R1,LOW);
    digitalWrite(right_R2,HIGH);
    analogWrite(PWM_R,pwm1);
  }
  else
  {
    digitalWrite(right_R1,HIGH);
    digitalWrite(right_R2,LOW);
    analogWrite(PWM_R,-pwm1);
  }
}
```

**Use Method:**

①installed well the balance robot, upload the test code;

②pull out the USB cable, then turn the power control switch of shield ON.

③the balance shield comes with a Bluetooth switch; then turn the switch ON. Refer to the project 6 on how to connect the Bluetooth module.

④Open the APP to connect Bluetooth; if Bluetooth connected, place the balance robot on the ground to make it stand upright. Then tap the Button key![image-20230510093100134](media/image-20230510093100134.png), you can control the robot go front, back, turn left or turn right by tapping the direction arrow icon.

![](media/c9025f5cc50b1c07224b747d3b8a75c8.png)

⑤press the key ![image-20230510093127734](media/image-20230510093127734.png)，you can also control the robot moving by gravity sensing system( must carried by your phone).

**Adjusting Balance Angle and PID by Bluetooth APP**

**Description:**

In the previous projects, we were able to control the car's upright balance and movement.

However, due to the error caused by the car installation and the mpu6050, the mechanical balance angle of the car is not perpendicular to the horizontal plane.

Thus when using Bluetooth controls the car’s forward or backward, its tilt angle is small and the wheel is almost motionless or moves slowly.

When controlling the car’s backward or forward, its tilt angle is very large and the wheel speed is very fast, so it is likely to accelerate over a certain distance and fall down.

![](media/85a352579f8f2a9fb2ada98cbab3804c.png)

In order to reduce these errors, we can adjust the mechanical balance angle and the main parameters of the PID through the mobile APP.

**How to use the Bluetooth APP?**

①follow the method mentioned before to upload the code to control the balance car move.

②set the tilt angle. When controlling the balance car, the front and rear speed of the car are not the same, so there is a deviation.

Then click the key ![image-20230510093304290](media/image-20230510093304290.png), get a tilt angle. Shown below.

![](media/fa3bb54a9c70e43446817767b86b4d45.png)

If get a negative number, type a positive number on the change bar ![](media/image-20230510093341512.png), so that the negative number plus the positive number equals to nearly 0.

Then click the key ![](media/image-20230510093405779.png), control the balance car move and observe the moving state.

③You can also press the PID![image-20230510093426650](media/image-20230510093426650.png) on the Bluetooth APP，to set the PID parameters，then tap other keys to adjust the PID parameters, making the balance robot stable. Or refer to the moving state of balance car under different parameters.

![](media/ae53906b471507cc4721fb6a913be783.png)

Settings finished, press the key![image-20230510093449645](media/image-20230510093449645.png) to return to the control interface.

**Source Code:**

**Note:**

Before test the source code, do remember to add the corresponding library.

You can refer to the method in the link below:

<https://wiki.keyestudio.com/How_to_Install_Arduino_Library>

```c
#include <MsTimer2.h>        //internal timer 2
#include <PinChangeInt.h>    //this library can make all pins of arduino UNO as external interrupt
#include <MPU6050.h>      //MPU6050 library
#include <Wire.h>        //IIC communication library

MPU6050 mpu6050;     //Instantiate an MPU6050 object; name mpu6050
int16_t ax, ay, az, gx, gy, gz;     //Define three-axis acceleration, three-axis gyroscope variables

//TB6612 pins
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

///////////////////////angle parameters//////////////////////////////
float angle_X; //calculate the inclined angle variable of X-axis by accelerometer
float angle_Y; //calculate the inclined angle variable of Y-axis by accelerometer
int angle0 = 0; //Actual measured angle (ideally 0 degrees) 
float Gyro_x,Gyro_y,Gyro_z;  //Angular angular velocity for gyroscope calculation 
///////////////////////angle parameters//////////////////////////////

///////////////////////Kalman_Filter////////////////////////////
float Q_angle = 0.001;  //Covariance of gyroscope noise
float Q_gyro = 0.003;    //Covariance of gyroscope drift noise
float R_angle = 0.5;    //Covariance of accelerometer
char C_0 = 1;
float dt = 0.005; //The value of dt is the filter sampling time
float K1 = 0.05; // a function containing the Kalman gain; used to calculate the deviation of the optimal estimate
float K_0,K_1,t_0,t_1;
float angle_err;
float q_bias;    //gyroscope drift

float accelz = 0;
float angle;
float angleY_one;
float angle_speed;

float Pdot[4] = { 0, 0, 0, 0};
float P[2][2] = {{ 1, 0 }, { 0, 1 }};
float  PCt_0, PCt_1, E;
//////////////////////Kalman_Filter/////////////////////////

//////////////////////PID parameters///////////////////////////////
double kp = 34.00, ki = 0, kd = 0.62;                   //angle loop parameter
double kp_speed = 3.60, ki_speed = 0.08, kd_speed = 0;   // speed loop parameter
double kp_turn = 24.00, ki_turn = 0, kd_turn = 0.08;                 // steering loop parameter
double setp0 = 0; //angle balance point
int PD_pwm;  //angle output
float pwm1=0,pwm2=0;

//////////////////interrupt speed count/////////////////////////////
#define PinA_left 5  //external interrupt
#define PinA_right 4   //external interrupt
volatile long count_right = 0;//Used to calculate the pulse value calculated by the Hall encoder (the volatile long type is to ensure that the value is valid）
volatile long count_left = 0;
int speedcc = 0;
//////////////////////pulse count/////////////////////////
int lz = 0;
int rz = 0;
int rpluse = 0;
int lpluse = 0;
int pulseright,pulseleft;
////////////////////////////////PI variable parameter//////////////////////////
float speeds_filterold=0;
float positions=0;
int flag1;
double PI_pwm;
int cc;
int speedout;
float speeds_filter;

//////////////////////////////steering PD///////////////////
int turnmax,turnmin,turnout; 
float Turn_pwm = 0;
int zz=0;
int turncc=0;

//Bluetooth//
int front = 0;//backward variable
int back = 0;//forward variable
int left = 0;//turn left
int right = 0;//turn right
char val;

int TT;

void setup() 
{
  //set the control pins of motor to OUTPUT
  pinMode(right_R1,OUTPUT);       
  pinMode(right_R2,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(PWM_L,OUTPUT);

  //assign the initial value
  digitalWrite(right_R1,1);
  digitalWrite(right_R2,0);
  digitalWrite(left_L1,0);
  digitalWrite(left_L2,1);
  analogWrite(PWM_R,0);
  analogWrite(PWM_L,0);

  pinMode(PinA_left, INPUT);  //speed encoder input
  pinMode(PinA_right, INPUT);

  // join I2C bus
  Wire.begin();                            //join I2C bus sequence
  Serial.begin(9600);                       //open the serial monitor, set the baud rate to 9600
  delay(1500);
  mpu6050.initialize();                       //initialize MPU6050
  delay(2);

  //5ms; use timer2 to set timer interruption (note：using timer2 will affect the PWM output of pin3 pin11)
  MsTimer2::set(5, DSzhongduan);    //5ms;  execute the function DSzhongduan once
  MsTimer2::start();    //start interrupt
}

void loop() 
{
  //Serial.println(angle);
  //delay(100);
  //Serial.println(PD_pwm);
  //Serial.println(pwm1);
  //Serial.println(pwm2);
  //Serial.print("pulseright = ");
  //Serial.println(pulseright);
  //Serial.print("pulseleft = ");
  //Serial.println(pulseleft);
  //Serial.println(PI_pwm);
  //Serial.println(speeds_filter);
  //Serial.println (positions);
  //Serial.println(Turn_pwm);
  //Serial.println(Gyro_z);
  //Serial.println(Turn_pwm);
  

  if(Serial.available())
  {
    val = Serial.read();      //assign the value read from serial port to val
    //Serial.println(val);
    switch(val)             //switch statement
    {
      case 'F': front=250; break;       //if vale equals F，front=250，go front
      case 'B': back=-250; break;       //go back
      case 'L': left=1; break;    //turn left
      case 'R': right=1; break;                         //turn right
      case 'S': front=0,back=0,left=0,right=0;break;    //stop
      case 'Q': Serial.print(angle);break;    //receiving‘D’，send the value of variable angle to APP
      case 'P': kp=kp+0.5,Serial.print(kp);break;
      case 'O': kp=kp-0.5,Serial.print(kp);break;
      case 'I': kd=kd+0.02,Serial.print(kd);break;
      case 'U': kd=kd-0.02,Serial.print(kd);break;
      case 'Y': kp_speed=kp_speed+0.05,Serial.print(kp_speed);break;
      case 'T': kp_speed=kp_speed-0.05,Serial.print(kp_speed);break;
      case 'G': ki_speed=ki_speed+0.01,Serial.print(ki_speed);break;
      case 'H': ki_speed=ki_speed-0.01,Serial.print(ki_speed);break;
      case 'J': kp_turn=kp_turn+0.4,Serial.print(kp_turn);break;
      case 'K': kp_turn=kp_turn-0.4,Serial.print(kp_turn);break;
      case 'N': kd_turn=kd_turn+0.01,Serial.print(kd_turn);break;
      case 'M': kd_turn=kd_turn-0.01,Serial.print(kd_turn);break;
    }
    if(val=='F'||val=='B'||val=='L'||val=='R'||val=='S'||val=='Q'||val=='P'||val=='O'||val=='I'||val=='U'||val=='Y'||val=='T'||val=='G'||val=='H'||val=='J'||val=='K'||val=='N'||val=='M')
    {
      TT = angle0;
    }
    else
    {
      TT = val;
      angle0=TT;
    }
    //Serial.println(angle0);
    
  }
  
  //external interrupt; used to calculate the wheel speed
  attachPinChangeInterrupt(PinA_left, Code_left, CHANGE);          //PinA_left Level change triggers external interrupt; execute subfunction Code_left
  attachPinChangeInterrupt(PinA_right, Code_right, CHANGE);       //PinA_right Level change triggers external interrupt; execute Code_right
}

/////////////////////Hall count/////////////////////////
//left speed encoder count
void Code_left() 
{
  count_left ++;
} 
//right speed encoder count
void Code_right() 
{
  count_right ++;
} 
////////////////////pulse count///////////////////////
void countpluse()
{
  lz = count_left;     //assign the value counted by encoder to lz
  rz = count_right;

  count_left = 0;     //Clear the count quantity
  count_right = 0;

  lpluse = lz;
  rpluse = rz;

  if ((pwm1 < 0) && (pwm2 < 0))                     //judge the car’s moving direction; if backward (PWM /motor voltage is negative), pulse is a negative number.
  {
    rpluse = -rpluse;
    lpluse = -lpluse;
  }
  else if ((pwm1 > 0) && (pwm2 > 0))                 //if backward (PWM /motor voltage is positive), pulse is a positive number.
  {
    rpluse = rpluse;
    lpluse = lpluse;
  }
  else if ((pwm1 < 0) && (pwm2 > 0))                 //judge the car’s moving direction; if turn left, the right pulse is positive; left pulse is negative. 
  {
    rpluse = rpluse;
    lpluse = -lpluse;
  }
  else if ((pwm1 > 0) && (pwm2 < 0))               //judge the car’s moving direction; if turn right, the right pulse is negative ; left pulse is positive. 
  {
    rpluse = -rpluse;
    lpluse = lpluse;
  }

  //entering interrupt per，pulse plus
  pulseright += rpluse;
  pulseleft += lpluse;
}

/////////////////////////////////interrupt////////////////////////////
void DSzhongduan()
{
  sei();  //allow overall interrupt
  countpluse();        //pulse plus subfunction
  mpu6050.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);     //IIC to get MPU6050 six-axis data ax ay az gx gy gz
  angle_calculate(ax, ay, az, gx, gy, gz, dt, Q_angle, Q_gyro, R_angle, C_0, K1);      //get angle and Kalman filtering
  PD();         // PD control of angle loop
  anglePWM();

  cc++;
  if(cc>=8)     //5*8=40，that is, execute the PI calculation of speed once per 40ms
  {
    speedpiout();   
    cc=0;  //Clear
  }
  turncc++;         
  if(turncc>4)       //20ms, that is, execute the PD calculation of steering once per 40ms
  {
    turnspin();
    turncc=0;     //Clear
  }
}
///////////////////////////////////////////////////////////

/////////////////////////////tilt angle calculation ///////////////////////
void angle_calculate(int16_t ax,int16_t ay,int16_t az,int16_t gx,int16_t gy,int16_t gz,float dt,float Q_angle,float Q_gyro,float R_angle,float C_0,float K1)
{
  float Angle = -atan2(ay , az) * (180/ PI);           //Radial rotation angle calculation formula ; negative sign is direction processing
  Gyro_x = -gx / 131;              //The X-axis angular velocity calculated by the gyroscope ; the negative sign is the direction processing
  Kalman_Filter(Angle, Gyro_x);            //Kalman Filter
  //Rotation angle Z-axis parameter 
  Gyro_z = -gz / 131;                      //angle speed of Z-axis
  //accelz = az / 16.4;

  float angleAx = -atan2(ax, az) * (180 / PI); //calculate the inclined angle of X-axis
  Gyro_y = -gy / 131.00; //angle speed of Y-axis 
  Yiorderfilter(angleAx, Gyro_y); //first-order filtering
}
////////////////////////////////////////////////////////////////

///////////////////////////////KalmanFilter/////////////////////
void Kalman_Filter(double angle_m, double gyro_m)
{
  angle += (gyro_m - q_bias) * dt;          //prior estimate
  angle_err = angle_m - angle;
  
  Pdot[0] = Q_angle - P[0][1] - P[1][0];    //The differential of the covariance of the prior estimate error
  Pdot[1] = - P[1][1];
  Pdot[2] = - P[1][1];
  Pdot[3] = Q_gyro;
  
  P[0][0] += Pdot[0] * dt;    //A priori estimation error covariance differential integral
  P[0][1] += Pdot[1] * dt;
  P[1][0] += Pdot[2] * dt;
  P[1][1] += Pdot[3] * dt;
  
  //Intermediate variables in matrix multiplication
  PCt_0 = C_0 * P[0][0];
  PCt_1 = C_0 * P[1][0];
  //denominator
  E = R_angle + C_0 * PCt_0;
  //gain value
  K_0 = PCt_0 / E;
  K_1 = PCt_1 / E;
  
  t_0 = PCt_0;  //Intermediate variables in matrix multiplication
  t_1 = C_0 * P[0][1];
  
  P[0][0] -= K_0 * t_0;    //Posterior estimation error covariance 
  P[0][1] -= K_0 * t_1;
  P[1][0] -= K_1 * t_0;
  P[1][1] -= K_1 * t_1;
  
  q_bias += K_1 * angle_err;    //Posterior estimate
  angle_speed = gyro_m - q_bias;   //The differential of the output value; get the optimal angular velocity
  angle += K_0 * angle_err; ////Posterior estimation; get the optimal angle
}

/////////////////////first-order filtering/////////////////
void Yiorderfilter(float angle_m, float gyro_m)
{
  angleY_one = K1 * angle_m + (1 - K1) * (angleY_one + gyro_m * dt);
}

//////////////////angle PD////////////////////
void PD()
{
  PD_pwm = kp * (angle + angle0) + kd * angle_speed; //PD angle loop control
}

//////////////////speed PI////////////////////
void speedpiout()
{
  float speeds = (pulseleft + pulseright) * 1.0;      //speed; pulse value
  pulseright = pulseleft = 0;      //Clear
  speeds_filterold *= 0.7;         //first-order complementary filtering
  speeds_filter = speeds_filterold + speeds * 0.3;
  speeds_filterold = speeds_filter;
  positions += speeds_filter;
  positions += front;             //Forward control fusion
  positions += back;              //Backward control fusion
  positions = constrain(positions, -3550,3550);    //Anti-integral saturation
  PI_pwm = ki_speed * (setp0 - positions) + kp_speed * (setp0 - speeds_filter);      //speed loop control PI
}
//////////////////speed PI////////////////////

///////////////////////////turning/////////////////////////////////
void turnspin()
{
  int flag = 0;      //
  float turnspeed = 0;
  float rotationratio = 0;
  
  if (left == 1 || right == 1)
  {
    if (flag == 0)                             //judge the current speed before turning, to increase the flexibility.   
    {
      turnspeed = ( pulseright + pulseleft);                      //current speed; pulse expression 
      flag=1;
    }
    if (turnspeed < 0)                                 //absolute value of current speed
    {
      turnspeed = -turnspeed;
    }
    if(left==1||right==1)         //if press the left key or right key
    {
     turnmax=5;          //the maximum value of turning
     turnmin=-5;         //the minimum value of turning
    }
    rotationratio = 5 / turnspeed;          //set by the speed of car
    if (rotationratio < 0.5)
    {
      rotationratio = 0.5;
    }
     
    if (rotationratio > 5)
    {
      rotationratio = 5;
    }
  }
  else
  {
    rotationratio = 0.5;
    flag = 0;
    turnspeed = 0;
  }
  if (left ==1)//add according to orientation parameter
  {
    turnout += rotationratio;
  }
  else if (right == 1 )//add according to orientation parameter
  {
    turnout -= rotationratio;
  }
  else turnout = 0;
  if (turnout > turnmax)   turnout = turnmax;//the max value setting of amplitude
  if (turnout < turnmin)   turnout = turnmin;//the min value setting of amplitude 

  Turn_pwm = -turnout * kp_turn - Gyro_z * kd_turn;//The rotation PD algorithm controls the fusion speed and Z axis rotation positioning
}
///////////////////////////steering/////////////////////////////////

////////////////////////////PWM end value/////////////////////////////
void anglePWM()
{
  pwm2=-PD_pwm - PI_pwm + Turn_pwm;           //assign the end value of PWM to motor
  pwm1=-PD_pwm - PI_pwm - Turn_pwm;
  
  if(pwm1>255)             //limit PWM value not more than 255
  {
    pwm1=255;
  }
  if(pwm1<-255) 
  {
    pwm1=-255;
  }
  if(pwm2>255)
  {
    pwm2=255;
  }
  if(pwm2<-255)
  {
    pwm2=-255;
  }

  if(angle>80 || angle<-80)      // if the tilt angle is greater than 45°，motor will stop turning.
  {
    pwm1=pwm2=0;
  }

 if(pwm2>=0)         //determine the motor’s turning and speed by the negative and positive of PWM
  {
    digitalWrite(left_L1,LOW);
    digitalWrite(left_L2,HIGH);
    analogWrite(PWM_L,pwm2);
  }
  else
  {
    digitalWrite(left_L1,HIGH);
    digitalWrite(left_L2,LOW);
    analogWrite(PWM_L,-pwm2);
  }

  if(pwm1>=0)
  {
    digitalWrite(right_R1,LOW);
    digitalWrite(right_R2,HIGH);
    analogWrite(PWM_R,pwm1);
  }
  else
  {
    digitalWrite(right_R1,HIGH);
    digitalWrite(right_R2,LOW);
    analogWrite(PWM_R,-pwm1);
  }
}
```

![](media/4431f0b71eb2d293ebcce752dfa32515.jpeg)



## Project 14: Adjusting Balance Angle and Bluetooth Control

**Description:**

In the above project, we first connect the Bluetooth and then adjust the balancing angle of car on the Bluetooth APP.

Now, we first adjust the balancing angle of car by hand; then connect the Android Bluetooth to control the car moving via Bluetooth APP.

**Notice:**

①　The balance shield comes with a slide switch for Bluetooth communication. When we upload the code for testing, turn the switch OFF, otherwise, the uploading fails.

②　When connecting it to Bluetooth module, we should turn the switch ON. 

③　Using the source code of this project, we can only adjust once each time starting up; adjust the angle first, otherwise the car can’t keep balance. 

**Source Code:**

**Note:**

Before test the source code, do remember to add the corresponding library.

You can refer to the method in the link below:

<https://wiki.keyestudio.com/How_to_Install_Arduino_Library>

```c
#include <MsTimer2.h>        //Internal timer2
#include <PinChangeInt.h>    //This library file can make all pins on the UNO board as external interrupts.  Define three-axis acceleration, three-axis gyroscope variables
#include <MPU6050.h>      //MPU6050 Library
#include <Wire.h>        //IIC communication library

MPU6050 mpu6050;     // Instantiate an MPU6050 object; name mpu6050 
int16_t ax, ay, az, gx, gy, gz;     //Define three-axis acceleration, three-axis gyroscope variables

//TB6612 pins definition
const int right_R1=8;    
const int right_R2=12;
const int PWM_R=10;
const int left_L1=7;
const int left_L2=6;
const int PWM_L=9;

const int buz = 11;
const int btn = 13;

///////////////////////angle parameters//////////////////////////////
float angle_X; // calculate the inclined angle variable of X-axis by accelerometer
float angle_Y; //calculate the inclined angle variable of Y-axis by accelerometer 
float angle0 = 0; //mechanical balance angle (ideally 0 degrees) 
float Gyro_x,Gyro_y,Gyro_z;  //Angular angular velocity by gyroscope calculation
///////////////////////angle parameter//////////////////////////////

///////////////////////Kalman_Filter////////////////////////////
float Q_angle = 0.001;  //Covariance of gyroscope noise    
float Q_gyro = 0.003;    // Covariance of gyroscope drift noise
float R_angle = 0.5;    //Covariance of accelerometer
char C_0 = 1;
float dt = 0.005; //The value of dt is the filter sampling time
float K1 = 0.05; // a function containing the Kalman gain is used to calculate the deviation of the optimal estimate
float K_0,K_1,t_0,t_1;
float angle_err;
float q_bias;    //gyroscope drift

float accelz = 0;
float angle;
float angleY_one;
float angle_speed;

float Pdot[4] = { 0, 0, 0, 0};
float P[2][2] = {{ 1, 0 }, { 0, 1 }};
float  PCt_0, PCt_1, E;
//////////////////////Kalman_Filter/////////////////////////

//////////////////////PID parameter///////////////////////////////
double kp = 34, ki = 0, kd = 0.62;                   //angle loop parameter
double kp_speed = 3.56, ki_speed = 0.072, kd_speed = 0;   // speed loop parameter
double kp_turn = 24, ki_turn = 0, kd_turn = 0.08;                 // steering loop parameter
double setp0 = 0; //angle balance point
int PD_pwm;  //angle output
float pwm1=0,pwm2=0;

//////////////////interrupt speed count/////////////////////////////
#define PinA_left 5  //external interrupt
#define PinA_right 4   //external interrupt
volatile long count_right = 0;//Used to calculate the pulse value calculated by the Hall encoder (the volatile long type is to ensure the value is valid)
volatile long count_left = 0;
int speedcc = 0;
//////////////////////pulse count/////////////////////////
int lz = 0;
int rz = 0;
int rpluse = 0;
int lpluse = 0;
int pulseright,pulseleft;
////////////////////////////////PI variable parameter//////////////////////////
float speeds_filterold=0;
float positions=0;
int flag1;
double PI_pwm;
int cc;
int speedout;
float speeds_filter;

//////////////////////////////turning PD///////////////////
int turnmax,turnmin,turnout; 
float Turn_pwm = 0;
int zz=0;
int turncc=0;

//Bluetooth//
int front = 0;//forward variable
int back = 0;//backward
int left = 0;//turn left
int right = 0;//turn right
char val;

int i,button;

void setup() 
{
  //set the motor control pins to OUTPUT
  pinMode(right_R1,OUTPUT);       
  pinMode(right_R2,OUTPUT);
  pinMode(left_L1,OUTPUT);
  pinMode(left_L2,OUTPUT);
  pinMode(PWM_R,OUTPUT);
  pinMode(PWM_L,OUTPUT);

  //assign the initial state value
  digitalWrite(right_R1,1);
  digitalWrite(right_R2,0);
  digitalWrite(left_L1,0);
  digitalWrite(left_L2,1);
  analogWrite(PWM_R,0);
  analogWrite(PWM_L,0);

  pinMode(PinA_left, INPUT);  //speed encoder input
  pinMode(PinA_right, INPUT);

  pinMode(btn,INPUT);
  pinMode(buz,OUTPUT);

  // join I2C bus
  Wire.begin();                            //join I2C bus sequence
  Serial.begin(9600);                       //open the serial monitor and set the baud rate to 9600
  delay(1500);
  mpu6050.initialize();                       //initialize MPU6050
  delay(2);

  //5ms; use timer2 to set the timer interrupt (note: using timer2 may affects the PWM output of pin3 pin11)
  MsTimer2::set(5, DSzhongduan);    //5ms; execute the function DSzhongduan once
  MsTimer2::start();    //start interrupt
}

 //buzzer
void buzzer()
{
    for(int i=0;i<50;i++)
    {
    digitalWrite(buz,HIGH);
    delay(1);
    digitalWrite(buz,LOW);
    delay(1);
    }
    delay(50);
    for(int i=0;i<50;i++)
    {
    digitalWrite(buz,HIGH);
    delay(1);
    digitalWrite(buz,LOW);
    delay(1);
    }
}

void loop() 
{
  //Serial.println(angle0);
  //Serial.print("angle= ");
  //Serial.println(angle);
  //delay(1);
  //Serial.println(PD_pwm);
  //Serial.println(pwm1);
  //Serial.println(pwm2);
  //Serial.print("pulseright = ");
  //Serial.println(pulseright);
  //Serial.print("pulseleft = ");
  //Serial.println(pulseleft);
  //Serial.println(PI_pwm);
  //Serial.println(speeds_filter);
  //Serial.println (positions);
  //Serial.println(Turn_pwm);
  //Serial.println(Gyro_z);
  //Serial.println(Turn_pwm);

  while(i<1)
  {
    button = digitalRead(btn);
    if(button == 0)
    {
      angle0=-angle;
      //Serial.println(angle0);
      buzzer();
      i++;
    }
  }
  if(Serial.available())
  {
    val = Serial.read();      //assign the value read from the serial port to val
    //Serial.println(val);
    switch(val)             //switch statement
    {
      case 'F': front=250; break;       //if val equals F，front=250，car will move forward
      case 'B': back=-250; break;       //go back
      case 'L': left=1; break;    //turn left
      case 'R': right=1; break;                         //turn right
      case 'S': front=0,back=0,left=0,right=0;break;    //stop
      case 'D': Serial.print(angle);break;
    }
  }
  
  //external interrupt; used to calculate the wheel speed
  attachPinChangeInterrupt(PinA_left, Code_left, CHANGE);          //PinA_left Level change triggers the external interrupt; execute the subfunction Code_left
  attachPinChangeInterrupt(PinA_right, Code_right, CHANGE);       //PinA_right Level change triggers the external interrupt; execute the subfunction Code_right
}

/////////////////////Hall count/////////////////////////
//left speed encoder count
void Code_left() 
{
  count_left ++;
} 
//right speed encoder count
void Code_right() 
{
  count_right ++;
} 
////////////////////pulse count///////////////////////
void countpluse()
{
  lz = count_left;     //assign the value counted by encoder to lz
  rz = count_right;

  count_left = 0;     //Clear count quantity
  count_right = 0;

  lpluse = lz;    
  rpluse = rz;

  if ((pwm1 < 0) && (pwm2 < 0))                     //judge the car’s moving direction; if backward (PWM namely motor voltage is negative), pulse is a negative number.
  {
    rpluse = -rpluse;
    lpluse = -lpluse;
  }
  else if ((pwm1 > 0) && (pwm2 > 0))                 //if backward (PWM namely motor voltage is positive), pulse is a positive number.
  {
    rpluse = rpluse;
    lpluse = lpluse;
  }
  else if ((pwm1 < 0) && (pwm2 > 0))                 //judge the car’s moving direction; if turn left, right pulse is a positive number; left pulse is a negative number.
  {
    rpluse = rpluse;
    lpluse = -lpluse;
  }
  else if ((pwm1 > 0) && (pwm2 < 0))               //judge the car’s moving direction; if turn right, right pulse is a negative number; left pulse is a positive number.
  {
    rpluse = -rpluse;
    lpluse = lpluse;
  }

  // enter interrupt per 5ms，pulse number plus
  pulseright += rpluse;
  pulseleft += lpluse;
}

/////////////////////////////////interrupt ////////////////////////////
void DSzhongduan()
{
  sei();  //allow overall interrupt 
  countpluse();        //pulse plus subfunction
  mpu6050.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);     //IIC to get MPU6050 six-axis data  ax ay az gx gy gz
  angle_calculate(ax, ay, az, gx, gy, gz, dt, Q_angle, Q_gyro, R_angle, C_0, K1);      //get angle and Kalmam filtering
  PD();         //angle loop PD control
  anglePWM();

  cc++;
  if(cc>=8)     //5*8=40，enter PI algorithm of speed per 40ms
  {
    speedpiout();   
    cc=0;  //Clear
  }
  turncc++;         
  if(turncc>4)       //20ms; enter PD algorithm of steering 
  {
    turnspin();
    turncc=0;     //Clear
  }
}
///////////////////////////////////////////////////////////

/////////////////////////////tilt calculation///////////////////////
void angle_calculate(int16_t ax,int16_t ay,int16_t az,int16_t gx,int16_t gy,int16_t gz,float dt,float Q_angle,float Q_gyro,float R_angle,float C_0,float K1)
{
  float Angle = -atan2(ay , az) * (180/ PI);           //Radial rotation angle calculation formula ; negative sign is direction processing
  Gyro_x = -gx / 131;              //The X-axis angular velocity calculated by the gyroscope;  the negative sign is the direction processing
  Kalman_Filter(Angle, Gyro_x);            //Kalman Filter
  //rotating angle Z-axis parameter
  Gyro_z = -gz / 131;                      //angle speed of Z-axis
  //accelz = az / 1604;

  float angleAx = -atan2(ax, az) * (180 / PI); //calculate the inclined angle with x-axis
  Gyro_y = -gy / 131.00; //angle speed of Y-axis
  Yiorderfilter(angleAx, Gyro_y); //first-order filtering
}
////////////////////////////////////////////////////////////////

///////////////////////////////KalmanFilter/////////////////////
void Kalman_Filter(double angle_m, double gyro_m)
{
  angle += (gyro_m - q_bias) * dt;          //prior estimate
  angle_err = angle_m - angle;
  
  Pdot[0] = Q_angle - P[0][1] - P[1][0];    //The differential of the covariance of the prior estimate error
  Pdot[1] = - P[1][1];
  Pdot[2] = - P[1][1];
  Pdot[3] = Q_gyro;
  
  P[0][0] += Pdot[0] * dt;    //The integral of the covariance differential of the prior estimate error
  P[0][1] += Pdot[1] * dt;
  P[1][0] += Pdot[2] * dt;
  P[1][1] += Pdot[3] * dt;
  
  //Intermediate variables in matrix multiplication 
  PCt_0 = C_0 * P[0][0];
  PCt_1 = C_0 * P[1][0];
  //denominator
  E = R_angle + C_0 * PCt_0;
  //gain value
  K_0 = PCt_0 / E;
  K_1 = PCt_1 / E;
  
  t_0 = PCt_0;  //Intermediate variables in matrix multiplication
  t_1 = C_0 * P[0][1];
  
  P[0][0] -= K_0 * t_0;    //Posterior estimation error covariance
  P[0][1] -= K_0 * t_1;
  P[1][0] -= K_1 * t_0;
  P[1][1] -= K_1 * t_1;
  
  q_bias += K_1 * angle_err;    //Posterior estimate
  angle_speed = gyro_m - q_bias;   //The differential of the output value gives the optimal angular velocity
  angle += K_0 * angle_err; ////Posterior estimation; get the optimal angle
}

/////////////////////first-order filter/////////////////
void Yiorderfilter(float angle_m, float gyro_m)
{
  angleY_one = K1 * angle_m + (1 - K1) * (angleY_one + gyro_m * dt);
}

//////////////////angle PD////////////////////
void PD()
{
  PD_pwm = kp * (angle + angle0) + kd * angle_speed; //PD angle loop control
}

//////////////////speed PI////////////////////
void speedpiout()
{
  float speeds = (pulseleft + pulseright) * 1.0;      //speed  pulse value
  pulseright = pulseleft = 0;      //clear 
  speeds_filterold *= 0.7;         //first-order complementary filtering
  speeds_filter = speeds_filterold + speeds * 0.3;
  speeds_filterold = speeds_filter;
  positions += speeds_filter;
  positions += front;             //Forward control fusion
  positions += back;              //backward control fusion
  positions = constrain(positions, -3550,3550);    //Anti-integral saturation
  PI_pwm = ki_speed * (setp0 - positions) + kp_speed * (setp0 - speeds_filter);      //speed loop control PI
}
//////////////////speed PI////////////////////

///////////////////////////turning/////////////////////////////////
void turnspin()
{
  int flag = 0;      //
  float turnspeed = 0;
  float rotationratio = 0;
  
  if (left == 1 || right == 1)
  {
    if (flag == 0)                             //judge the speed before rotate, to increase the flexibility
    {
      turnspeed = ( pulseright + pulseleft);                      //current speed ; express in pulse
      flag=1;
    }
    if (turnspeed < 0)                                 //speed absolute value
    {
      turnspeed = -turnspeed;
    }
    if(left==1||right==1)         //if press left key or right key
    {
     turnmax=3;          //max turning value
     turnmin=-3;         //min turning value
    }
    rotationratio = 5 / turnspeed;          //speed setting value
    if (rotationratio < 0.5)
    {
      rotationratio = 0.5;
    }
     
    if (rotationratio > 5)
    {
      rotationratio = 5;
    }
  }
  else
  {
    rotationratio = 0.5;
    flag = 0;
    turnspeed = 0;
  }
  if (left ==1)//plus according to direction parameter
  {
    turnout += rotationratio;
  }
  else if (right == 1 )//plus according to direction parameter
  {
    turnout -= rotationratio;
  }
  else turnout = 0;
  if (turnout > turnmax)   turnout = turnmax;//max value of amplitude
  if (turnout < turnmin)   turnout = turnmin;//min value of amplitude 

  Turn_pwm = -turnout * kp_turn - Gyro_z * kd_turn;//turning PD algorithm control
}
///////////////////////////turning/////////////////////////////////

////////////////////////////PWM end value/////////////////////////////
void anglePWM()
{
  pwm2=-PD_pwm - PI_pwm + Turn_pwm;           //assign the end value of PWM to motor
  pwm1=-PD_pwm - PI_pwm - Turn_pwm;
  
  if(pwm1>255)             //limit PWM value not greater than255
  {
    pwm1=255;
  }
  if(pwm1<-255) 
  {
    pwm1=-255;
  }
  if(pwm2>255)
  {
    pwm2=255;
  }
  if(pwm2<-255)
  {
    pwm2=-255;
  }

  if(angle>45 || angle<-45)      //if tilt angle is greater than 45°，motor will stop
  {
    pwm1=pwm2=0;
  }

   if(pwm2>=0)         //determine the motor steering and speed by negative and positive of PWM
  {
    digitalWrite(left_L1,LOW);
    digitalWrite(left_L2,HIGH);
    analogWrite(PWM_L,pwm2);
  }
  else
  {
    digitalWrite(left_L1,HIGH);
    digitalWrite(left_L2,LOW);
    analogWrite(PWM_L,-pwm2);
  }

  if(pwm1>=0)
  {
    digitalWrite(right_R1,LOW);
    digitalWrite(right_R2,HIGH);
    analogWrite(PWM_R,pwm1);
  }
  else
  {
    digitalWrite(right_R1,HIGH);
    digitalWrite(right_R2,LOW);
    analogWrite(PWM_R,-pwm1);
  }
}
```

**How to use ?**

①installed well the balance robot, upload the test code;

②pull out the USB cable, then turn the power control switch of shield ON. Keep the car balance; when the motor rotates, press the button key 13, and buzzer will make a “tick”. In this case, the car is adjusted well.

③follow the Bluetooth control methods mentioned above; connect the Bluetooth module to make the balance robot run using APP.  

Refer to the project 6 on how to connect the Bluetooth module.

![](media/dc310dcc455c5e90b283b05285c5f89a.jpeg)





# 7.All Resources Download

**https://fs.keyestudio.com/KS0193** 





